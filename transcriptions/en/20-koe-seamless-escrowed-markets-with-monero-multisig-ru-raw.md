# koe

_**Seamless Escrowed Markets with Monero Multisig**_

[https://youtu.be/S478LukKlEs](https://youtu.be/S478LukKlEs)

---

_**koe:**_ Hi, everyone! I will talk about how to build an escrowed market using Monero multisig. What I'm talking about today could be built with today's Monero multisig, but what I'm going to be talking about is a more efficient version that's "seamless" as I call it.

So first we're gonna talk about how Multisig works today, or not today, but how multisig works in Monero. Multisig is a technology where multiple people can collaborate to build a Monero wallet, and then the multisig group members collaboratively own the funds. So we call this "M-of-N" when if we have a group of size N, so for example three people, and then M is two, so two of three, you need two people from the group of three in order to make any transaction, spending funds from the multisig wallet.

So to set up a multisig account, all of the group members start out with a set of base keys. So there is a main base key pair, which is going to initialize the multisig component. And then there's also a common base key pair which is combined, as we see at the bottom here, into the multisig common private key as simply a hash of the component private keys from the group members. And this shared private key is used as the multisig group view private key, so all of the group members have the same view key. And then this private key can also be used to sign messages as a member of the group.

And then also, group members have their own personal signing key, which is used as a member identifier and is required to sign all messages produced by a given group member. And these signatures are necessary in order to properly validate messages that are passed between group members.

So to set up a multisig account, we use a Diffie-Hellman based key exchange algorithm. So in the beginning, the group members send all of their main key pair public keys, and also their common key pair private keys to all the other group members. The common private keys are immediately combined into the multisig shared group common private key, but the main public keys are used to make Diffie-Hellman exchanges. So each of the group members uses their main key pair to produce a Diffie-Hellman exchange with all of the base public keys of the other group members. So we have shared secrets between each pair of group members.

So now if we're in an intermediate round, these Diffie-Hellman secrets are sent directly to all of the other group members. And then in the next round, another Diffie-Hellman exchange is made with these, the prior rounds, Diffie-Hellman key pairs. So what you end up with is each unique key that is produced will have three members in providing Diffie-Hellman components to the secrets that are produced. And you continue on until you have sufficient number of participants in these Diffie-Hellman secrets. Once you have a sufficient number, you, instead of sharing the Diffie-Hellman secrets, you hash them, so this is in the last round, minus one up here, hash the secrets, multiply by the multisig generator, or the key generator, the generator of the key that you want to produce. And then you send these public key shares. So these are the key share components of each signer. These are sent to all of the other signers. And then you combine all the key shares into the completed multi-sig public key.

And what we do here is something called key aggregation, so we have this equation here. We don't add them together directly. We first multiply by a factor that ensures you can't do something called key cancellation, which violates the multisig invariance. And then of course we have the common public key, which is simply the shared private key times the generator.

So an important security note for the key exchange process is you must have a post-key exchange verification round where you obtain a copy of the completed public key from all of the other members in the group. And then you require that all of the other group members have the same completed final public key. And we do this because if you don't check that all of the other group members have a completed public key, then it's possible that one of them is blocked by a malicious group member and is unable to complete the multisig account, which means that the expected group size is actually reduced. And it could be that you have no way to make a signature without the cooperation of that malicious signer who blocked other signers.

Now, I came up with some optimizations to this process that can be used if you properly validate that you will not break your invariance if you use these optimizations. As you can see on the bottom, I say use with care here.

So one of the optimizations is force-updating one of the key exchange rounds. So that you can complete a round without messages from all of the signers. Because when we had these Diffie-Hellman exchanges where multiple people have components of the secret normally you want a recommendation from each of those members. So you receive recommendations from each of those members for that copy of the key share, and then you verify that all of them have the same recommendation. And you need that to uphold the invariance of the key exchange process. But when we're force updating, we might only require that one or more of the shareholders of each given secret recommends that key.

The second optimization is something called "round boosting", where you have, say, one person and then two other people. And let's say this person over here gets the messages from the previous key exchange round from those people and immediately updates their personal cache to the next round without waiting or without ensuring that the other members are also in lockstep updating their accounts. So basically, the other people make incomplete next-round messages that this signer can use to move forward in the key exchange protocol.

Now, if these optimizations are used improperly, then you can end up with a key hostage attack where a malicious signer is required to participate in all signatures. Or you can get a frozen account. For example, if you force update the post key exchange verification round, if you force update that, then you could end up, as I discussed earlier, with a situation where not all signers are able to participate in signing. And so later on I will point out, so I will use these optimizations in the escrow market discussion, and then I will point out later on how those use cases are valid.

So when you're going to make a multisig transaction, you begin with a transaction proposal from one of the group members, which specifies the signer set, the subset of size M from the group who you want to participate in that transaction attempt. And you also specify the transaction inputs and outputs, the fee and the memo that you want to be in the transaction. And then each other member can check this transaction protocol. They can create a transaction simulation from the proposal details and validate that the transaction could theoretically be completed by simulating a transaction. And you also must check that the inputs of the transaction are owned, unchained, and unspent. And you must verify that the outputs recorded in that proposal are acceptable.

So if you want to sign a multisig transaction, you have to go through a signing ceremony, which has three components. First, each member initializes the signature by providing nonces for the signature. In multisig, each member is required to provide two nonces to mitigate something called the Drijver's attack, which is a very technical attack, but very important to mitigate. Otherwise, the key shares of other members can be stolen in specific situations. And then once you have the nonces from all of the other signers in the subgroup, you respond with partial signatures from each of the members, and then you combine the partial signatures into the full signature. And of course then you should check that the full signature is valid.

What I implemented in the Seraphis library, or alongside the Seraphis library, is aggregation style signing where you in advance you coordinate which key shares will be provided by each of the members. So each of the group members will, or between the group members there will be duplicates of key shares because between subsets of the group will be shared secrets. And so we have to coordinate which members provide which of the shared secrets. And we do that by, we know in advance which subgroup will be participating in signing. So we only provide key shares from the lowest member in the subset with a given key share.

And then also in Monero multisig, we have multisig signing in a transaction - when you sign a transaction your signature has two components. It has the spend private key component and also view key material. And the view key material is known by all of the multisig group members while the private key component is split between all of the group members. So the multisig signing is all about that private spend key. And so we can simply provide, in the multisig, in Monero multisig transaction signing, each of the signers can provide fractional components of the view key material that is known by all the members.

All right, with that out of the way, we can discuss how this can be applied to an escrow marketplace with the caveat that what I'm discussing is experimental, incomplete, and probably insecure. Hopefully not, but probably.

So in an escrowed multi-market, we have three players. We have the buyer who encounters a vendor with some product, and we have a third-party arbitrator who handle disputes between the buyer and the vendor. So in this scenario, we use a 2-of-3 multisig where most of the time we expect the buyer and the vendor to cooperate to pass funds from the buyer to the vendor. So buyer into multisig to the vendor.

So in a 2-of-3 we have to set up the account, we have three rounds. We begin with the base keys. So all the base keys are passed to other participants. And then they make Diffie-Hellman exchanges. Convert those to public keys between each pair, so three sets, and then these are sent to all of the other players, and then those are aggregated into the completed public key. And then of course, those public keys are expected to be passed around again for the post-key exchange verification round.

So what we want, so we want a buyer to encounter a vendor, set up the multisig account, fund the multisig account, create a transaction, moving funds out of the multisig account and into the vendor, all in one step. And then we want the vendor to receive this information, send the product out, begin signing the transaction, and send that information to the buyer, and then when the buyer receives the product, they complete the transaction and submit it to the network. We don't want the buyer to do any more steps, so we want the buyer to encounter the product and ask for it, receive the product, and pay, and finish paying. And those are the only two things we want the buyer doing.

So the real important to achieve this workflow, the most important thing is single step buyer setup. So to do this, we use both of the optimizations that I discussed previously.

To begin, the vendor cooperates with the arbitrator, so both of them have to be online for the preparation component. The vendor and the arbitrator cooperate to produce the base keys and boost round 2 messages. So the round 2 is that Diffie-Hellman exchanges between each pair to the vendor and arbitrator produce Diffie-Hellman public keys, and these between themselves, but not between themselves and the buyer, who doesn't exist yet. So this is a speculative setup for the vendor and the arbitrator.

So we say we're boosting round 2 because the round 2 message produced is incomplete. It does not contain Diffie-Hellman public keys between, like, for example, the vendor and the buyer. So the setup information is prepared by the vendor and published alongside their product offer. And then, so the buyer encounters the base keys, the round 2 boosted messages and the product offer, which allows him to complete the account setup in one step. So he uses the base keys provided by the vendor. He uses the round 2 messages which are boosted to complete round 2 and then he force updates the post key exchange validation round. And later on I will justify the use of these optimizations here.

And so for this to be safe, however, the buyer needs to know that the arbitrator is alive in some way. So either by pinging the arbitrator or through some heuristic that's left up to the implementer. Because if the arbitrator is not alive, then it's possible for funds to be trapped in the address.

So once the buyer did their single setup, they have a completed account, they fund the account, they make a proposal removing funds from the account and sends their setup information, like the messages they produced while doing account setup, they send all of this information to the vendor who can now set up his own account. So that vendor, it's important for the vendor to do the normal account setup process. So he uses the buyer and arbitrator's base keys to set up, then he cooperates with the arbitrator to obtain the round 2 messages from the arbitrator. He does round 2, he does post key exchange validation, and then he'll have a completed account with two important notes here.

If there is no arbitrator, then the vendor needs to force update his, he needs to force his account into completion so that the funds which are already in the multisig account can be removed from that account one way or another. I say we follow the refund path here because the vendor hasn't actually sent the product out yet. So since there's no arbitrator, we might as well refund and abort. And then, of course, we must be caution here that it's very important for the arbitrator to validate buyer messages, because buyer messages are forwarded through the vendor to the arbitrator. So the vendor could replace the buyer's messages with anything they want and perhaps set up a sock puppet buyer. I'll discuss later how we prevent that.

So here's an overview of the escrow setup process. The vendor prepares their account and makes a product offer. The buyer encounters this information, completes their account in a single step, sends funds to the multisig account, and then immediately produces multisig transaction proposals removing funds from the multisig account. And we can do this without waiting. In Seraphis, we can do this without waiting for the multisig account funds to arrive in the account, so to be unlocked. So we don't have to wait 10 blocks because in Seraphis, we can... multisig transaction proposals can be chained off of enotes which are not yet unlocked or even in the chain at all. And then, so when the vendor receives all of this information, they complete the account with the arbitrator, they wait for the funds to be unlocked or to be confirmed and unlocked in the account, and then sends the product and moves forward with the transfer of funds to the vendor.

So here's the cooperation route, which I've kind of talked about, alluded to so far. So when the buyer initiates a trade, we do this at the same, so this is specifically about the transfer of funds. So when the buyer initiates trade, he makes a payment and a refund transaction proposal and initializes those transactions and sends all that information to the vendor. So we try to do the payment and the refund paths in parallel as much as possible to improve the user experience.

As I discussed before, the initialization of the trade happens at the same step as the buyer set up. So the buyer sets up their account, funds the multisig and initializes the trade. And then the vendor receives that information from the buyer and begins the transfer. So if they choose, let's seeâ€¦ So, assuming the arbitrator is gone, then we simply go to the refund path. Other ways, we do both payment and refund paths in parallel here.

So at the vendor finish set-up step, the vendor completes his account with the arbitrator and sends the product to the buyer, along with initializations for the payment and refund transactions. So these are the nonces I talked about before. And then along with partial signatures for just the payment path. We don't want partial signatures for the refund path. Otherwise the buyer could simply refund himself immediately. The buyer then receives all this information and either receives the product or does not receive the product. If he receives the product, he chooses the payment path. He completes the payment transaction, submits it to the network, sends the transaction ID to the vendor, and then the vendor can later on check that the funds have been sent, and close out the trade. If he follows the refund path, then he partially signs the refund transaction and sends that information to the vendor. And then in the refund path, there's a further step for the vendor who must finalize the refund by completing the transaction, submitting it, and then sending the resulting transaction ID to the buyer.

Now, if the cooperation path, or the cooperation route, I say, does not work out, then we need to go through arbitration. So let's say the buyer wants a refund and the vendor is not cooperating. He sends sufficient account setup information to the arbitrator, for the arbitrator to complete their account. And he also creates a refund transaction proposal and initializes it and sends that to the arbitrator so that the arbitrator can, in the next step, approve the refund, check that the account is funded as expected after setting up their account. So the arbitrator force updates their account in one step with only round data from the buyer in addition to the vendor's base keys which can be cashed by the arbitrator. So the arbitrator can cash the vendor must register with the arbitrator and then the arbitrator can later check that vendor information sent by the buyer is properly registered. And then of course the arbitrator signs the refund transaction, sends it to the buyer, buyer finishes the transfer, straightforwardly.

And then there's the mirror arbitration route for the payment if the vendor wants payment. And all of the steps are the same here. So the information for force-updating the account is sent to the arbitrator. The arbitrator sets up in one step signs the payment and vendor finishes that.

Okay, so those are the main details for the escrowed market workflow that I'm presenting here, but there are many ways this can go horribly wrong. So we should talk about some, go through some safety notes here.

So one the most the largest danger here is sock puppets. So the buyer and the arbitrator do not normally or make contact with each other. So the vendor is forwarding buyer information to the arbitrator during the vendor setup phase and also when the vendor is asking for arbitration with the arbitrator. So since to prevent the vendor from modifying buyer messages, we require that all transactions funding the account, which are referenced by multisig transaction proposals, include proofs that - so a transaction funded proof is a proof that the signer of the proof send funds into or created a transaction or funded a specific transaction. So all of the transactions funding the multisig account must have a transaction funded proof signing a message from the buyer. So the buyer's information, the vendor product amount and a vendor signature on the product info. So that the product, the transfer that is being done here is locked into the transaction funded proof. And only the buyer is able to make this transaction funded proof because only the buyer funds the account. And even if the vendor funds the account and produces one of these transaction funded proofs, the arbitrator will not cooperate with any transaction proposal which spends funds provided by a transaction that does not have a transaction funded proof that maps properly to the buyer info forwarded by the vendor. So that prevents the vendor from making buyer sock puppets that can cause funds to be removed from the account without following the proper or satisfying the invariance you expect.

And on the other side, the when the buyer goes to arbitrate with the get a refund from the arbitrator it's possible that he registered a vendor sock puppet with the arbitrator beforehand and then uses that sock puppet to convince the arbitrator to go forward with the refund. So we prevent this by the arbitrator must enforce that the vendor based public keys, which are used for the multi-stake setup are unique. We expect that the vendor only registers his base keys before any product offers. So there's no race conditions between the vendor and the buyer. And then obviously, we require that the arbitrator expect all vendor messages are signed by a registered vendor ID.

Now we can see why the optimizations that I've mentioned throughout the talk are valid. So there are four cases here. During buyer setup, the vendor and arbitrator boost round 2 and then the buyer uses those boost messages to boost his own round 2. And this is valid because the vendor and arbitrator don't need an account yet. So it's acceptable for the buyer to go forward with his account completion without interacting with the vendor and arbitrator.

Then also during buyer setup, we force-update the post key exchange verification round, which I consider valid because we assume that the arbitrator is honest and available. And we know in advance that any refund arbitration can be completed by just the buyer and the arbitrator. So there's no need to check that the vendor is available or not, because arbitrator setup only requires the buyer. Then if there's no arbitrator and the vendor has to do a refund, he force-updates, runs 2 and 3, which is valid because the vendor's on the refund path and has no stake in the funds in the multisig account. So only the buyer has stake and only the buyer has provided key exchange messages.

Now in both of the arbitration paths, we have the arbitrator force updating both of rounds 2 and 3, which I consider valid because the arbitrator has no stake. And before the account set up, the arbitrator has already decided that the setup partner who is collaborating with this force-updating situation has full stake of the funds in the multisig account. So even if there's no reason for there's nothing to be gained by that partner for violating any of the usual multisig variants.

And then finally, if we need arbitration and there's no arbitrator, then you could technically implement a vendor-buyer split funds protocol as a fallback. And also, an important thing to note about this protocol is that the buyer has privacy versus the arbitrator in the cooperation path. So most of the time, the arbitrator should learn nothing about the buyer because the arbitrator can assist the vendor setup without the buyer contact details. The arbitrator does not need to validate, does not need these transaction funded proofs, or these proofs are only needed on the arbitration paths. So the buyer info here does not need to be sent to the arbitrator except in the arbitration path. So importantly, the arbitrator learns nothing about the buyer other than the buyer's base keys and round 2 keys in the typical path.

That is the end. Thank you.
