# Suyash Bagad

_**MProve+: Privacy Enhancing Proof of Reserves for Monero**_

[https://youtu.be/KGgBB3pDl3Y](https://youtu.be/KGgBB3pDl3Y)

---

_**Suyash:**_ Hello, everyone! I will not take a lot of time since it's the last talk for today. I'm Suyash. I currently work for the Aztec Protocol, and the work I'm presenting was done as a part of my master's thesis which is MProove+, which is essentially privacy enhancing proofs of reserves for cryptocurrency exchanges, specifically for Monero. So it's a cryptographic protocol. I'll avoid going into the mathematical details, but just try to give a high-level overview of what do we mean by proofs of reserves and what this technique is about.

So, exchanges. We already know, if it's not your key, it's not your coins - so a lot of people store or trade in cryptocurrencies and have accounts on cryptocurrency exchanges which facilitates seamless onboarding or even trading. But the problem is you have to trust the cryptocurrency exchange that your keys will be stored safely, which is apparently not the case. There's lots of cases of hacks, frauds, exit scams. Lots of exchanges, recently there was this FTX saga - people using the user deposits for other reasons. So we have seen all of these different unfavorable scenarios back since I think 2014 or even before. So Mt. Gox was the largest exchange hack back in 2014. You had exit scams like QuadrigaCX, which is still like a mystery and they have like a Netflix documentary apparently. Recent one, FTX as I mentioned. So all of these are not really favorable from a user point of view. If cryptocurrency needs mass adoption, right now cryptocurrency exchanges seem to be the only, not only, but one of the main sources for people to onboard to crypto. But if such things keep happening, we need some solutions.

One solution, which is not very popular for the masses is to use hardware wallets where your private keys are stored on the hardware wallet and they don't interact directly with the internet. So it's considered safer than using an exchange, obviously. But again, this is very hard for general people, common people to use. And we are still far from having things like credit cards or hardware wallet that sits in a card that could be used for payments and so on. So therefore, this is not currently a viable option for a lot of common people.

Other option could be to solve the problem of exchanges or the inherent nature of trusting exchanges if we could bring in some trust using some math and that's what proofs of solvency are for, where basically an exchange, if an exchange proves that it owns more reserves than its liabilities, then at least we can be sure that in case of any hacks or in case of any unfavorable scenarios, the users could be returned their hard-earned money.

But the problem with this is the kind of proofs of solvency or proof of asset that people talk about are problematic because they could reveal sensitive information about the exchange. For example, after this FTX problems, I think Binance released a list of their addresses which cumulatively stored like $69 billion or something. But then this is very bad for Binance or business of Binance, because they had to reveal sensitive information about their assets. So this could still be done for public blockchains because Bitcoin, Ethereum are public blockchains and people can see what's the balance of assets given an address. But what about private blockchains like Monero where it's not even possible to see what the balance is? So this is still just one aspect of proof of solvency, which is proof of assets.

What about liability? So liability generally mean the amount that users have deposited into crypto exchanges and the crypto exchange owes to the users. So proof of liability is even more difficult because it is very difficult for an exchange to reveal customer data and therefore proof of assets is slightly easier to work around than proof of liabilities.

So coming back to proof of assets, today we are going to talk only about proof of assets. The protocol we have designed is proof of reserves or proof of assets. And the key idea for a blockchain like Monero is to prove the same relation that assets minus liabilities must be greater than equal to zero. But then we can do this with commitments. So let's say C is like a commitment, sorry, C could be like a generator. So generator to the power Assets is like a commitment to the total assets. Generator to the power –Liabilities is, let's say, a commitment to the total liabilities and if you multiply CAssets times C–Liabilities, and if you can prove that this is a commitment to a non-zero number, or some number that is greater than zero, then that should be enough to prove assets is greater than liabilities. So this is the main idea that we use.

So there's a few challenges that we need to tackle before we start using this equality that we saw. First of all, proof of reserves with Monero is hard. So we had two iterations of design of this protocol. First one is called MProve. Second one is MProve+. There was a big flaw in MProve design, which we'll see. And we'll also see why these proofs of reserves are hard.

So typically like a Monero transaction, the idea of using ring signatures to hide what your address is in a given ring is what Monero uses. So if P is your public key, let's say the green circle, then you just prove that you own one public key out of 11 or whatever is the ring size. And corresponding to that public key, you also need to supply some more information which is called “key image” to prevent double spending of that address. And as I already said, the ring signature basically proves that the transaction sender knows one of the private keys corresponding to these public keys in the ring, and key image helps detect double spending.

So the proof of reserves protocol that we'll talk about today, both of them are based on similar lines, because essentially what an exchange wants to do with a proof of reserve is it wants to prove that it owns certain addresses which contain certain amount of money and then the sum of that money should be greater than a threshold. So as I said, the key idea here is in a normal Monero transaction, we just have one public key that we prove the ownership of. Now we want something more. We want to prove that there's this unspent, there's this huge set of unspent transactions from which the cryptocurrency exchange will prove that it owns a certain subset of exchanges.

So the way MProve works is fairly straightforward. So let's say these green addresses are the set of addresses owned by the exchange. So the first thing that exchange will do is it will just choose like an anonymity set to hide its own addresses, just like what we saw for the Monero transaction, and let's call this anonymity set as Panon. So, for each address that we choose in this anonymity set, there's a commitment which is defined something like this, where g and h are, again, these are generators for which the discrete log between them is not known, assumed to be not known. yi is your blinding factor, it's like secret. And ai is the amount so the Ci will be a commitment to amount ai.

So for each address the exchange owns, what that means is basically it knows the secrets yi and ai, and that basically means that the address is owned by the exchange. So to do proofs of reserves, we need to somehow prove that from given this anonymity set, which is just a bunch of addresses, there corresponds some commitments. And from those set of commitments, there are certain commitments for which we know the secrets.

So the first step, that first computation that we need to do here is sample a random scalar, zi, and compute this quantity, . So we call it as modified commitment because it looks similar to the definition of commitment. And if you see, we do like a conditional computation here where the modified commitment is just , where zi is the random scalar that we only know. So zi is again a secret that the exchange knows. And if the address is owned by the exchange, it's just simple public key computation generator zi. If it's not an address owned by the exchange, then we also multiply it with the commitment of that address. And we'll see why we do that.

So if we look at the modified commitment and the original commitment that we have, there's an implicit relationship between them. So if you just try to compute this quantity here, the commitment times the inverse of the modified commitment. So one thing that you will see here is, if the address is not owned by the exchange, then the modified commitment and the commitment relation is slightly easier. So there is no edge term in that case. But when we have, when the crypto exchange owns that address, this now becomes a commitment to amount ai with a slightly different blinding factor. So blinding factor becomes yi – zi, which let's ignore for now. But the point is this quantity here modified, sorry, commitment times modified commitment inverse, that becomes like a commitment to the amount, original amount ai. For the addresses that the exchange owns. For the addresses that it doesn't own, it becomes a commitment to zero.

So now the interesting thing is, if we sum all of these over the ring, what we'll get is there will be some g term, g to the power something, and the h term will contain some of the amounts. And those amounts will be corresponding to the ones that are owned by the exchange. So therefore, this becomes like a commitment to the total reserves or total assets owned by the exchange. So this was what we were trying to do, right? If we have a commitment to the assets and assuming if we have a commitment to the liabilities, the exchange can do a range proof to prove that the multiplication of assets commitment times liabilities commitment inverse that it can prove that it's a commitment to a non-zero number. So we take one thing from here, but then we still need to prove that the modified commitment was computed correctly, as the crypto exchange we need to prove that.

So how do we prove is using ring signatures. So we note that the modified commitment has a certain structure. So very simple structure here is zi can be thought of like a private key and the modified commitment becomes the public key when the address is owned by the exchange. When it's not owned by the exchange, you can again think of it like a key pair where secret key is again zi and public key is modified commitment times the inverse of the original commitment. So the point of showing this is we can compute a ring signature using these two public keys, the green one and the orange one. So green represents the addresses that are owned by the exchange. Orange represents the addresses that are not owned by the exchange. And if we can give a ring signature, then we basically prove that the structure of the modified commitment was correctly performed. Because if the exchange didn't know the zi or if the structure was not preserved, then the exchange would not be able to produce a ring signature. So this is a regular ring signature.

The only thing that remains in MProve protocol is we still need to prove that the addresses that we have included in our anonymity set, they are not already spent. And we saw that we used the notion of key image to prove that an address is not already spent. So, therefore, we somehow need to reveal the key image of your original address, the address owned by the cryptocurrency exchange. So again, for that you use ring signatures on two public keys. One is Pi, which is shown in green, that corresponds to the address owned by the exchange. And the orange part is again for the addresses that are not owned by the exchange.

So why this ring signature? Because we want to prove that when the cryptocurrency exchange is owned by the, owned by the, sorry, address is owned by the exchange, we want to prove that that address corresponds to the correct key image, but we cannot just reveal the key image directly, because that would just reveal which addresses are owned by the exchange. Therefore, we give a ring signature. So the probability, so for an external, person, this just looks like the probability of guessing, which address is owned by the exchange is 50%. So therefore, we have this second linkable ring signature, because we also want the key image corresponding to the second ring signature, so that the exchange can also prove that the green address Pi was not already spent.

So this is essentially the improved protocol, which is fairly simple, but there are very critical drawbacks of this. One of which is, as is the case with general Monero transaction, this also scales linearly in the anonymity set size, but the problem, but the larger problem here is, the anonymity set size for exchanges is desirable to be very large, because the exchange wants to reveal as much less information about what addresses it owns as it's possible. So scaling linearly is not a great thing and therefore it adds limits on the anonymity set size. But a more critical problem is revealing the key image corresponding to the addresses that the crypto exchange owns.

Now why is this a problem? Because if the exchange, let's say, spends from the address which it included in, let's say it gives a proof of reserves and proof of reserves in 2020, and then it spends that one of its addresses, it spends the money in 2021. So any future transaction will reveal that the exchange is trying to spend from a particular address, which is very dangerous for the privacy of the exchange. So therefore this is not practical to be adopted. And therefore we have MProve+ which solves this drawback.

So the key idea of MProve+ - we just look at the problem or write the problem in a slightly different manner. So it's pretty mathematical, but I'll just try to give a very high level overview, which is we define these binary vectors corresponding to the addresses that the exchange owns. So for example, the green address at position two is owned by the exchange. So there will be one in the first vector, first binary vector. And similarly, we can define the other binary vectors. The blinding factor y and the amounts will only be known by the exchange for obviously for the addresses that it actually owns. Commitments, we'll have commitments corresponding to all public keys in our anonymity set, and of course the public keys of our actual anonymity set. There's a couple of other things like key images corresponding to the, I think, apparent key images for each of the public keys that I have not shown in the slide, but yeah, those things, yeah, kind of are obvious.

So the idea here is, If we write the problem statement in this way, what we can do is we can say that a particular commitment can be computed as the commitment vector raised to the power of the binary vector. So for example, for gth commitment that the exchange owns, it can just compute it, it takes C vector. It can raise it to the C vector, binary vector. Similarly, it can write the relationship between the address it owns and the generator and the secret key. And similarly, it can also write the relationship between the key image for the addresses it owns.

So Ij here is the key image, ej is the secret key corresponding to that address. And the point of doing all of this is we can combine all of these relations into a single relation. So the translation from separate equations to single equation is slightly involved. But the idea is you just randomly, sorry, combine these equations with powers of a random challenge. And what that gets you is a relationship between all of these public vectors. So you see C vector, P vector, H vector, all of these are public. And the exponents of that are secrets the binary vector ej. On the right, again, we have g, h, I are public and the exponents are private, and we get an inner product relation between the exponents or secrets. So the idea is vectorize all the relations and just combine them into one equation. This is how the equation looks like. This is from the paper. I have not expanded it here.

So once we have this kind of single equation where all of the public information is in the base, all of the secret is in the exponent, we can use a very powerful tool from the Bulletproofs paper. I think it was originally from a paper before Bulletproofs, but a lot of people give credit to Bulletproofs paper. So this inner product argument from the Bulletproofs paper can be used, because if you look at the inner product argument here, all of the public information is in the base. All of the secrets are in the exponents with some inner product relation between the secrets. And therefore, we can use the same inner product argument for this as well. I'm not going to the details, as I said. But what the inner product argument is pretty powerful because it reduces your proof size from linear to logarithmic in the total size. So total size, capital N here, is the total size of your vectors. So in this case, it's the number of secrets times the number of addresses in your anonymity set because, so we have ej for all j that belongs to the exchange. So each, size of each ej is N, and the number of vectors ej is the number of addresses it owns. So capital N will be N times number of addresses owned by the exchange. So therefore the proof size, in this case also, it grows linearly with, sorry, the anonymity set size. But the scaling constant factor is almost 12x. So we get a lot of proof size reduction.

Generally, MProve+ proofs are 8x shorter than that of MProve. Yeah, this is just a plot of the proof size. Proof generation verification time of MProve+ is slower than MProve, because the protocol MProve was very simple. You have standard ring signatures, linkable ring signatures, but in case of MProve+ you have this huge exponentiation that you need to compute, and therefore the prover as well as the verifier work is a lot more in MProve+. Although the proof verification is much cheaper than the prover work. Although both of them are linear, there is a lot of opportunities for batching, just like we do in usual Monero transactions. So proof verification is almost 8x faster than proof generations.

So what we achieved with this was, MProve+ solves the critical vulnerability or problem of MProve, and it makes it almost practical to run proofs of reserves for exchanges. Proof sizes are much smaller, as I said, because at some point the exchange will publish these proofs on chain, and therefore there's a cost associated with the proof size. So smaller proof size are always better. Therefore it's possible today for exchanges to run MProve+.

Is it practical though? That's still a question because if you, so the numbers that we ran, it takes almost two hours to run, to generate a proof for anonymity set size of 50,000 addresses. So for a big exchange like Binance, if it owns, let's say, 1,000 Monero UTXOs or addresses, it's almost inherently will ask to have the anonymity set size as large as possible. But it takes, so this is on a commodity hardware, but still it takes two hours to generate a proof. And if we consider, let's take the entire UTXO set as the anonymity set because that would be the ideal case for exchanges to preserve maximum privacy, it would almost be impossible unless you have a very beefy machine and still it would take hours to generate a proof.

So we have been constantly working to try out new protocols like SNARKs and STARKs to see what could speed up the prover and verify time. Verify time is also critical because if these proofs of reserves are going to be included in the chain, they will, at some point, will be validated by the miners or validators. So one of the projects that we have made quite good progress on is actually coming up with a proof of reserves using the Nova proof system, specifically for Monero. So we'll publish that as soon as we have some results.

And the last thing is just the couple of implementations that we have. One is in Rust, one is in the Monero source code. So please feel free to take a look and throw questions at us.
