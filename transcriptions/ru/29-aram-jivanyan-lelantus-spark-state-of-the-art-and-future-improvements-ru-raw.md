# Арам Дживанян

_**Текущее состояние Lelantus Spark и будущие улучшения**_

[https://youtu.be/EJBj97CH910](https://youtu.be/EJBj97CH910)

---

_**Арам:**_ Привет всем, я Арам Джаванян, криптограф из Firo. Сначала я хочу поблагодарить организаторов за приглашение. Я очень рад находиться сегодня здесь и рассказать вам немного больше о Lelantus Spark, нашем конфиденциальном платёжном протоколе, разработанном совместно с Аароном и получившим лестные отзывы от koe, Люка и Николаса. Сегодня мы обсудим основные функции конфиденциальности и опыт пользовательского взаимодействия с этим протоколом.

Кратко обсудим его модель безопасности и рассмотрим ключевые характеристики производительности. Затем обсудим несколько потенциальных предложений по будущим улучшениям и ответим на вопросы в ключе предстоящих исследований. Итак, Lelantus был разработан в 2019 году и с тех пор использовался в нескольких криптовалютных проектах, таких как Firo и Beam. Я так же считаю, что Lelantus вдохновил криптографоф на создание других конфиденциальных протоколов, таких как Lelantus MimbleWimble, Triptych и Seraphis. Изначальная версия Lelantus позволяла масштабировать размер набора анонимной группы до нескольких тысяч монет. Протокол также позволял обеспечить конфиденциальность суммы, но этому механизму не хватало одной очень важной функции - конфиденциальности получателей. Spark решает эту проблему с помощью простой, но не менее интересной схемы адресации, которая не только обеспечивает конфиденциальность получателя, но и делает протокол более дружелюбным к аппаратным кошелькам. Протокол уже поддерживает операции с мультиподписью и предоставляет более вариативный контроль над монетами и транзакциями. Давайте посмотрим, как это вообще работает.

На этой схеме секрет пользователя состоит из трех функциональных компонентов, которые, в свою очередь, используются для получения трех различных ключей. Первый из них называется ключ просмотра входящих транзакций. Ключ просмотра входящих транзакций позволяет сгенерировать разнообразные публичные адреса, которые в свою очередь будут переданы отправителям. Ключ просмотра входящих транзакций также предназначен для сканирования реестра и идентификации входящих транзакций, отправленных на любой из диверсифицированных адресов, сгенерированным данным ключом.

Второй ключ называется ключом полного просмотра. Он позволяет отслеживать не только входящие, но и исходящие транзакции, чтобы вы могли видеть, когда и куда определённая монета была потрачена, и, как вариант, поддерживать необходимый баланс вашего кошелька. И, что наиболее важно, данный ключ используется для выполнения самых ресурсоёмких операций в процессе генерации транзакций, что означает, что его можно хранить на менее надёжных, но более производительных устройствах, например, в десктоп версии кошелька, в то время как ключ траты используется только для очень простых операций, например, чтобы просто подтвердить доказательство владения. И да, его можно хранить на аппаратных кошельках. В дополнение часть ключа, которая используется для генерации ключа траты, также может быть сгенерирована с помощью мультиподписи.

На диаграмме вы видите выделенные жирным строки, которые показывают, что компоненты не являются явной частью ключа, но используются в фиксированной форме. По сути, криптографические соглашения являются фундаментальным строительным блоком протокола. Все подпроцедуры, входящие в Spark, такие как параллельные доказательства "один из многих" или доказательства диапазона, или обобщенные доказательства Чаума-Педерсена, работают с обычными обязательствами Педерсена.

Spark работает с моделью UTXO, где пользователи создают и зачем уничтожают монеты. Каждая монета состоит из двух отдельных компонентов: соглашения стоимости и соглашения серийного номера. В отличие от оригинальных монет Lelantus, которые имеют более монолитную структуру, монеты Spark могут создаваться с помощью транзакций Mint и Spend.

Mint используется для передачи монет базового уровня в защищённый слой и также для защиты Coinbase-транзакций. Spend-транзакция используется для погашения уже созданных монет и генерации новых. А теперь давайте рассмотрим некоторые детали этого алгоритма транзакций.

Это пример, который использует два входа и затем создаёт два новых выхода. Все входы должны ссылаться на определённый набор анонимности. В процессе создания транзакции в начале создаются два смещённых соглашения: одно содержит стоимость исходной монеты а второй серийный номер.
Эти соглашения кодируются те ми же значениями, что и исходные монеты, чтобы избавиться от потенциального посотавления. Транзакции Spend создают специальное доказательство членства, показывающее, что эта пара фактически соответствует другой паре монет в наборе анонимности, не раскрывая связи. Затем транзакция создает новые монеты с соглашениями стоимости и серийного номера.

После получения соглашения о стоимости, вместе с транзакцией предоставляется доказательство баланса с нулевым разглашением, а также доказательство диапазона, чтобы убедиться, что ни один из выходов не будет содержать отрицательное значение.

В конце транзакции раскрываются связывающие теги для уже потраченных монет, которые используются для предотвращения двойной траты, а также блок информации для генерации доказательства владения с использованием алгоритмов Чаума-Педерсона.

Связывающие теги играют очень важную роль в предотвращении двойных трат и формировании доказательства владения. По сути, они генерируются на основании серийного номера монеты, фактически из значений SI в этих формулах, которые также закодированы в соглашении о серийном номера. Затем используются протоколы Sigma, чтобы доказать, что эти два соглашения кодируют одни и те же значения, тот же серийный номер. Исходный протокол chomp — это доказательство, которое позволяет гарантировать равенство дискретных логарифмов. Обобщенная версия позволяет доказать, что элементы определённой степени в более общих соглашениях также равны, и также позволяет генерировать несколько утверждений с более оптимизированным доказательством.

Поскольку доказательство Чаума-Педерсена довольно похоже на подпись Шнорра или протоколы типа Шнорра, это также позволяет нам поддерживать мультиподписные операции. Для мультиподписи мы предоставляем модифицированные алгоритмы генерации ключа и доказательства авторизации. Но самое важное заключается в том, что эти новые доказательства расхода в системе Андреаса полностью неразличимы от оригинальных. Кроме того, для поддержки этих операций не требуется никаких доверенных дилеров. Мы используем различные техники из известных протоколов мультиподписи Frost и Music, разработанных для подписей Шнорра.

Давайте также обсудим, как мы поддерживаем наборы анонимности. Монеты добавляются постепенно в глобальный пул монет, и мы логически делим глобальный пул на наборы анонимности фиксированного размера, например, потенциально до 65 000 монет. Вместо того чтобы сразу начать создание второго набора, мы начинаем, сдвигая влево точку старта на, скажем, 60 000 монет.

Это необходимо, чтобы гарантировать, что ни один новый начатый набор анонимности не будет достаточно пустым, и в нем будет достаточно монет для обеспечения высокой анонимности. Таким образом, наборы анонимности будут последовательно следовать друг за другом, и каждое доказательство расхода должно быть сгенерировано и явно ссылаться на конкретный набор анонимности. Например, первые два доказательства здесь ссылается на первый набор, а первое доказательство ссылается на четвёртый набор анонимности.

Это также важно для оптимизации проверки транзакций. Самая ресурсоёмкая часть проверки транзакции Spark - это проверка доказательства "один из многих", что в свою очередь сводится к проверке больших мультиэкспонентных операций. И в этим множестве экспонент базовыми точками являются, по сути, соглашения в наборе анонимности. Предположим, у нас есть два доказательства, каждое из которых ссылается на один и тот же набор анонимности. Эта часть проверки, которая использует эту множественную экспоненту, использует одни и те же базовые точки, верно? Что позволяет нам математически объединить их и фактически проверить два доказательства с помощью одной множественной экспоненты.

Эти техники позволяют нам проводить очень оптимизированную пакетную проверку транзакций. Эта таблица показывает некоторые цифры с текущими бенчмарками. Я верю, что ещё есть возможности для инженерной оптимизации, но на данный момент при ограничении размера набора до 65 000 монет, размер транзакции будет около 6 килобайт. Время доказательства составит 6 секунд. Проверка одной транзакции займёт около 860 миллисекунд, но можно увидеть, что при проверке пакета размером, скажем, 100 транзакций, предельная стоимость проверки одной транзакции снизится до 30-31 миллисекунды.

Я также хочу упомянуть, что протоколы сопровождаются полными формальными доказательствами безопасности. Мы используем систему безопасности, впервые разработанную и использованную в протоколе Zerocash, которая моделирует очень надёжную структуру, где злоумышленникам разрешается добавлять вредоносные монеты в транзакции, в наборы анонимности, контролировать выбор входов транзакций и добавлять произвольные транзакции в сам реестр. В этой структуре мы формально доказали, что SPARC обеспечивает три свойства безопасности: свойство баланса, свойство неразличимости реестра и свойство немодифицируемости транзакций. Первое означает, что ни один злоумышленник не может изменить транзакции пользователя и не может перенаправить выходы до того, как транзакция будет добавлена в реестр.

Свойство неразличимости реестра в основном охватывает как анонимность, так и конфиденциальность транзакций. Оно доказывает, что ни один злоумышленник не может узнать больше, чем публично раскрыто в реестре. Право собственности баланса гарантирует, что ни один злоумышленник не потратил и не сможет потратить больше монет, чем он создал или получил.

Да, это о Spark, и что касается будущих улучшений. Сейчас мы рассматриваем возможность замены доказательств членства на более эффективные и инновационные доказательства членства, называемые Curve Trees, как обсуждалось вчера c koe. Самая тяжёлая часть транзакции Spark остаётся параллельным доказательством "один из многих". Почему параллельное доказательство "один из многих"? Потому что механизм Spark показывает, что монеты состоят из двух различных серийных соглашения, верно? Поэтому мы должны доказать, что для данного набора пар соглашений и данных смещённых соглашений оба смещённых соглашения кодируют ту же стоимость, что и одна из пар в наборе анонимности.

Curve Trees представляют собой очень эффективные доказательства членства, и мы надеемся, что они смогут заменить доказательства "один из многих", если мы найдём способ реализовать параллельную версию Curve Trees, чтобы она могла работать с парами соглашений, или мы придумаем, как изменить структуру наших монет, чтобы они работали с обычными Curve Trees.

Другой интересный открытый вопрос для исследований, который у нас сейчас на повестке дня, — это исследование метода пакетного доказательства для Curve Trees. Это, на самом деле, вдохновлено другой нашей оригинальной работой в FIRA под названием иерархические доказательства "один из многих", что позволило нам сократить время доказательства. Точнее, не время доказательства, а внедрить очень эффективные техники метода пакетного доказательства.

Остаётся открытым и интересным вопросом для исследования, сможем ли мы реализовать что-то подобное в Curve Trees для оптимизации генерации доказательств. Потому что на практике, в потраченной транзакции, всегда приходится генерировать доказательства как минимум для двух входов.
