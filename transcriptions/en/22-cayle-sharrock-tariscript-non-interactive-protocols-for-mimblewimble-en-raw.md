# Cayle Sharrock

_**TariScript: Non-interactive protocols for Mimblewimble**_

[https://youtu.be/tVk64lLurCU](https://youtu.be/tVk64lLurCU)

---

_**Cayle Sharrock:**_ Good afternoon, everyone. We're the last stretch, and then we can have that first beer of the day. Some of you – third beer of the day, I've seen.

So, "TariScript: non-interactive protocols for Mimblewimble", or perhaps a better title is "How We Added Scripting to Mimblewimble".

So the roadmap for the talk. Essentially, before I can talk about TariScript, I have to introduce Mimblewimble and Tari. This is a Monero crowd, and I assume not everyone here is aware of what Mimblewimble is. So I'm gonna have to take a little bit of a dive into, you know, Tari, how it relates to Monero, what makes it interesting and how confidential transactions work, and why it's hard to do scripting in vanilla Mimblewimble. And then also why we need it in Tari, right?

So Tari is a fast scalable private digital assets protocol which is merge-mined on Monero. So that's the main link. The second link is that one of the founders of Tari is none other than fluffypony. So there's kind of a rich history between the two projects.

And judging by some of the conversations I've had this weekend, rumors of Tari's demise have been greatly exaggerated. We've been working hard for the last couple of years to build this protocol. And it's architected on two layers.

So the layer one is what we call the Minotari chain. This is a proof of work based protocol built on Mimblewimble, hybrid proof of work. 60% of the blocks are merge-mined with Monero.

And underneath that is a second layer, which is the digital assets network. That's where the smart contracts run. That's where all the cool and interesting stuff is. And I'm not gonna talk about that at all today. What I am gonna talk about is how we enhance Mimblewimble to allow the link between the layer one and layer two.

All right, so Mimblewimble 101, what is it? Mimblewimble is basically like Bitcoin. It's a cryptocurrency protocol, but it has confidential transactions. So if you look at a block explorer for Bitcoin, you can see the entire transaction graph. You can see who sent how much and to whom. So it makes the perfect surveillance coin ultimately.

Mimblewimble is far more private. It has what I call "Ok" privacy. Very technical term. And the reason why I say that is because if you look at a block explorer for a Wimblewimble chain, all you see are inputs and outputs. And there's no way to tell which inputs are related to which outputs. It's essentially a coinjoined on the block level. And that helps obfuscate the transaction graph. And of course, all the values have been hidden. And I'll get into exactly how that works in a second.

Of course, the problem is that a committed and a motivated adversary can scan the network and if they put enough nodes in the network, they can actually monitor the peer-to-peer network for transactions, which are atomic things, and reconstruct the transaction graph in that way. So the privacy for Mimblewimble is good, is okay, it's not fantastic, certainly nowhere near as good as Monero's.

What Mimblewimble does do well is its scalability. And so what the security guarantees or the security trade-offs that Mimblewimble makes is that once you've spent a transaction, you can just throw it away. You don't have to worry about it anymore. In order to validate the state of the chain. All you really need is the set of unspent outputs. So all the coins that are in circulation, you just need to know what those are and the emission curve. And you can essentially do a trustless verification of the state of the chain. There's a bunch of other housekeeping that you have to do, but in terms of the accounting, that's it. And because of that, if Bitcoin had to be done in this way, you could probably throw 80% of the blockchain. So it's a good scalability solution, but it's also interactive.

Now, there's some math ahead. I was gonna say, if you're offended by math, there's a trigger warning, but given some of the talks we've had today, I guess that horse is bolted. So all I want to say to you is that if you've got high school maths, you will be able to follow along with my talk. I've tried to keep it as accessible as possible.

All right, so let's start with how confidential transactions work. The key problem is here is how can a node take a transaction that it receives on the blockchain or in the network and know that we're not creating or spending, doing funny things without actually knowing the amounts involved. It sounds like black magic, right? So, yeah, I'm about to reveal how that's done.

So let's take an example transaction. Alice has some output, she has 100 Tari, she wants to send some to Bob. And so the transaction's gonna look something like this. She's gonna spend that output, Bob needs to have an output after the fact, she'll have some change, and of course, he needs some fees.

Now, in a blockchain like Bitcoin, where everything's out in the clear, the nodes can do the accounting directly. So they'll see the transaction, and they'll simply compare the outputs and the inputs and say are they equal, right? Do the outputs minus inputs equal zero? In this case, the outputs is 10 for Bob, 89 change for Alice, assuming there's like a one Tari fee and she's spending 100 and we add that up, we get zero. Okay, cool. No one's doing anything nefarious.

But how do we do this without knowing the values? So you've seen this word a couple of times today already – Pederson commitments. So what is actually happening here? So in the kind of the cryptography that we use for this type of thing, elliptic curves or ECC, essentially the normal rules of arithmetic apply, right? Addition and multiplication work the same way as any high school algebra problem. So you can take any number k, and we multiplied by some constant G and you get some value P, all right? So k times G equals P.

Now, in ECC, that's easy to do. Multiplication is easy, so we can calculate P. The thing is that if I give you P, you cannot say P divided by G. You'll never be able to figure out k. Not without an insane amount of computing power. I say never, but technically the purists will say, that's not true, but in practice, you basically cannot find k. So all the orange values are public all the white values are secret. And you may be starting to guess that the white values are secret keys and the orange values are public keys. And this is kind of essentially public-private key cryptography right here.

Okay, so that's step one. Step two is commitments, right? So what we do next is – because the normal rules of arithmetic apply, you know the good old communicative rule and the associative rule, distributive rule of maths where A plus B is the same as B plus A, or A plus B plus C is the same as A plus B plus C – you can do all the same arithmetic tricks with ECC values. So when we create a commitment, we're actually adding two things together. We take some secret value times by a constant and another secret value times by a constant, and we sum them together, we get what we call a commitment. And if you have two different commitments, you have this nice property that if you add these two commitments together to get a third commitment, C. It's exactly the same answer as if you had added those two secrets together and those two values together and done the commitment math in that route, and you get the same answer. And that's called the homomorphic property of the commitments. And that's kind of the secret source for Mimblewimble.

So let's add some semantics to these commitments. So what we have is in a Mimblewimble output, it's actually represented by these commitments here. And it's the sum of sum value times G, which that secret value is actually what is the spend key. Knowing that value lets you be able to spend the output. And the actual value of the output is multiplied by H. So those are the two secret values of a commitment to Mimblewimble. But what we're showing, what we expose in the blockchain are just the sum. So once I've added these two together, there's nothing you can do. You'll never be able to separate them again. It's like me saying to you, the sum, I've got two numbers in my head, and they add up to a million. What are the two numbers? There's no real way for you to figure out what the two numbers are without brute forcing every single combination, right? And the number is, the sum here doesn't go up to a million, it goes up to an astronomically huge number. So there's no practical way of separating these two.

Okay, so with that introduction out of the way, let's see how the same balance on Tari has done versus how it was done on Bitcoin.

So in the same way, Alice is spending an output to Bob, getting some change and doing a fee. And because in Mimblewimble, these are represented by commitments, it's going to be a Ca, Cb. Ca prime is her change commitment. So that's got a value of 100 and some spend key. Bob's has got a value of 10 and some spend key. And her change is 89. And if we do the balance here, we're just adding these commitments together, inputs upwards minus inputs. And because of that associative rule, we can combine all the H terms together, and we combine all the G terms together, and you'll see how this is kind of cool. The values cancel out, right? Same as on this side. But on the G's, we've got the sum of what effectively is the sum of all the secret keys, all the spending keys. And that's like the residual. That's what's left over.

All right. So what is the significance of this? Is that when you've got the sum of all the keys and you multiply by G, this is like a public key. And when you have a public key, you can create a digital signature signing with the secret key. So what we do in Mimblewimble entirely is that a node will receive just a bunch of commitments. It'll do the balance in the usual way and then check if the result is the public key corresponding to a signature the spenders provide with the transaction. And if that signature checks, then they know that the I values must have canceled out. And that's how we know that no coins have been created or destroyed, but we have no idea what the values were. Okay, that concludes our lesson.

All right, so let's see, what is the spend authority here? On Bitcoin, Alice will be providing, you know, she'll be sending, she'll be providing the spending script for her output, the locking script for the change, and Bob's output, and effectively Bob provides nothing, right? This is completely non-interactive – Alice sends everything herself.

On Tari Alice provides knowledge of ka and va, so the output that she's spending, she'll create a secret for her change, but she can't create the secret for Bob's output. If she did, she'd be able to spend his output, right? So Bob needs to come in into the story and provide his secret, his kb. And that's why Mimblewimble's interactive. And that makes things challenging when you want to do things like tip jars and withdrawing from exchanges and mining pools. A mining pool can't be expected to wait for everyone to come online to pay their dividends and so on. So this is a challenge and something that in Tari we wanted to resolve. We also had other things we wanted to do between a Tari's layer one and layer two, and that is things like doing pegouts to the side chain or to the layer two, doing covenants and all sorts of other things to manage our smart contracts.

So let's take a step back. We can summarize. Vanilla Mimblewimble transactions are confidential – okay, they're interactive. And the other thing is it's just math, right? There's nothing fancy. It's not like Bitcoin where you can add scripts. Some of you might not know, when you send to a Bitcoin address, there's no real, it's not really going to an address. There's a script that gets evaluated and the unlock script has to match the signatures and so on. But with Mimblewimble, it's essentially just a signature, it's just maths.

So then how do we go about implementing atomic swaps, sidechain pegs, one-sided payments, view keys, covenants, hash time, lock contracts, and then stupid things like BRC 20s. Thing is, in vanilla Mimblewimble you can't, you can't do it, so, enter TariScript. 15 minutes in and we finally get to the cracks of the talk.

So, how do we do this? Well, it comes down to two things. We modified one consensus rule, and we added another one. So the first thing we did is that we changed the spending rule for Tari outputs is that in order to spend a Tari output you need to know two things: the spend key, which is the existing Mimblewimble rule, you need to know the k value, and now you also have to know something that we've introduced called the script key, and that's the extra rule.

There's also a new consensus rule that says: when you create an output, or when you must provide a script with that output, and when you spend it, you can add some input. You can provide whatever input you want to the script, but the script must run correctly by the consensus rules, by the node, and the result must be a single value, and that single value must be a public key. And then the spender must prove knowledge of the private key that corresponds to that public key. So that private key is what we're calling the script key over there.

So how do we implement this in Tari? We invented something called TariScript script and it's inspired by Bitcoin script. It's a stack-based language, very similar to Forth or Bitcoin script. It's not Turing complete, so there's no loops in it. But it's got opcodes for things, normal mathematic operations. You can do signatures, you can do hashing. There's some blockchain metadata you can pull in, like the block height, and it has conditionals, so you can do some funky conditional logic. So it's kind of smart contract light. It's got strict limits enforced by the consensus rules and size and complexity, so there's no halting problem issues, every script is guaranteed to finish.

So let's look at some examples. So the easiest one is, what does the standard Mimiblewimble, the standard interactive Tari transaction look like? And in this case, the script is the simplest script you can think of, it's a no-op. Doesn't do anything. And so when the spender is spending, they just stick any public key that they want as the input. The no-op script runs, leaving that key on the stack, and that satisfies the rule. Script is executed, and there's a single public key on the stack. And unless the spender's a complete moron, they will know the private key to the public key that they've just pushed up. And presumably, they already know the spend key, they satisfy the new consensus rules. So this is, again, requires interactivity and doesn't deviate from standard mobile.

I think something that's more interesting is one-sided payments. So now Alice can send something to Bob, and Bob is not involved at all, similar to a Bitcoin transaction, right, or a Monero transaction. And the script in this case is that Alice will, the script is to push Bob's public key onto the stack, and when Bob spends it, he provides no input. So it will execute and it'll just have Bob's public key on the stack. Right, so that takes care of that part. What about the spend key?

So when Alice is creating this transaction, she creates a shared secret between her and Bob using something called Diffie-Hellman key exchange. And it's a standard technique for two parties to create a shared secret and no observers can figure out what that secret is, but those two parties know it, it's a shared secret.

Now that wouldn't work in normal Mimblewimble because once Alice has broadcasted the transaction, she'd know that secret so she could spend Bob's output, right, so not ideal. However, now with TariScript, she doesn't know the private key to Bob's public key. So out of the two of them now, only Bob is able to spend that coin and in Bob's example you've got one-sided payments.

You could do even funkier things like, Elizabeth earlier was talking about atomic swaps and you need a refund condition and that sort of thing. This is the script that would say: before block 4000, for example, only Bob's public key would be pushed onto the stack. But after block 4000, either Alice's or Bob's public key would be left on the stack after this runs. And so both of them could spend it. So up until block 4,000, only Bob can spend. Beyond 4,000, either Alice or Bob can spend. So she can get her funds back in case of a failed atomic swap, as an example.

All right, so that's essentially a rush through. That's the movie version of TariScript. I've left out a lot of detail. For that, you've got to go and read the book. And the things I've left out is that the basic idea of TariScript as I presented it here was something like I thought of in a couple of days, put the initial spec together in a week or so, but it took us the better part of a year to actually get the protocol finished and in a place that we think is secure.

And because there are a couple of problems with the way it's presented, and in order to dig into that, you might want to ask me about cut-through and how that stuffs up the whole TariScript idea, how we manage to resolve those problems and fix them. And once that's done, you might want to ask me what horizon attacks are and how that can stuff up the TariScript approach and what we do to handle that in Tari. But in the interest of time, we can discuss that over a beer.

Ultimately, as I said, this took the better part of a year. It was an absolute massive team effort. So I really have to acknowledge the entire Tari core development team for taking the RFCs, finding vulnerabilities, fixing it, finding another vulnerability, and iterating again and again, and every time getting a little bit closer to the goal. And also to David Burkett, who was experiencing similar issues when he was trying to implement one-sided payments for Litecoin extension blocks. And we're really indebted to him. He contributed a lot as well. And I think it's fantastic that we work in an industry where people are ostensibly competing projects can work together to solve common problems. It's like we're more engrossed with solving the tech problems than trying to win some arbitrary competition. So thanks to those guys. That's it. Let's gonna over beer.
