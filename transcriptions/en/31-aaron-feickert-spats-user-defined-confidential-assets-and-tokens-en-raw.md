# Aaron Feickert

_**Spats: User-defined Confidential Assets and Tokens**_

[https://youtu.be/jpdiXfqVeuI](https://youtu.be/jpdiXfqVeuI)

---

_**Aaron:**_ I'm Aaron, and I'm going to talk about Spats, which is a new protocol designed for user-defined confidential assets and also supports tokens too.

So first of all, this is joint work with Aram, who is a cryptographer with Firo, associated with Yerevan State University, who's also here. So you can talk to him about some of the work on this. And he's actually going to talk about Spark, the base protocol for this, a little bit later.

Just as a disclaimer, I work as head of research at Cypher Stack, a research consultancy, and the research for Spats was conducted as part of work for Firo. And as always, this is for informational use only. Importantly, this hasn't undergone formal external review yet, so it's still very much work in progress. It does have some formalization, but it's still incomplete. Obviously, this is not professional advice.

So first of all, let's do a brief overview about why we might wanna talk about confidential assets and tokens, and how that fits into existing protocols.

So we have some confidential protocols like RingCT, like Seraphis, like Spark, which shares some of the same kind of underlying framework ideas as Seraphis. They can already do some really interesting things that we generally like. So one important thing is using stealth addressing techniques. We can dissociate recipient addresses from the coin data that's generated and actually goes on chain, to separate those. We can also importantly provide ambiguity about the spend status of coins, which ideally makes it uncertain whether or not a particular coin has been spent at any particular point on the chain. But we can also protect things like coin values and other metadata using encryption and commitments and other cryptographic techniques.

But importantly, they only support a single asset type. And by that I mean a single defined supply of that asset that can be transferred around between different users in the system. And what we'd like to do is see, can we extend this to support multiple asset types that importantly have independent supply?

We're not talking about doing weird on-chain exchanges between asset types, which requires information like exchange data and gets very ugly very fast. We're interested in supporting multiple asset types whose supply is maintained independently. So a supply of asset A, B, and C, you can transfer around A, B, or C, but ideally, you want to protect which asset is being transferred, and maintain a consistent supply between them. Whatever your issuance rules say about what that supply is supposed to be.

So in particular, we want to be able to protect the both value and asset type in a transaction. I shouldn't be able to look at a transaction and say, that's transferring asset A or asset B or asset C. I should just see it's transferring something, and I don't know what it is, and I don't know how much it is.

And separately, we might also want to support things like non-fungible tokens, which was not really the initial idea for this research. But when we came up with it, someone asked: "Oh, can this support things like tokens?" And I was like: "I don't know." And then a few hours later, I came back and said: "Yes, it can." I know a lot of people do not like the idea of tokens, because they don't like what it does and messes with chains and stuff. Whatever, like, this is math. We do things because problems are interesting. If you want to use it, great. If not, you don't have to. This can just support assets too, and not necessarily tokens.

And in the case of non-fungible tokens, we'd also want to make sure that we protect whatever kind of serialization or identifier represents that token as part of a transaction. So we like transactions to be nice uniform blobs of nothing as much as possible. That's not possible in practice, but it's a goal. You gotta have goals, right?

So how do we actually represent value in transactions right now? So this is already stuff that exists, but in case you're not terribly familiar with the way that these protocols like RingCT, Spark, Seraphis work, how do we represent value in a way that allows us to maintain balance and supply, but do it in a safe way that doesn't make that wide public knowledge on chain? So we do that with what are called cryptographic commitments.

What a commitment lets you do, it lets you take a coin that has some value v, which is just some number, and in part it can be represented, because there's other coin data too, by what's called a commitment. And the commitment hides the value, so you don't know what it is, and it also binds the value, which means I can't hand you this commitment blob and later be like: "Oh no, no. It actually represents this amazingly large value that I now control." No, this should be able to be done in a unique way. So we wanna be able to bind the value to the commitment.

The way we do that is by choosing a random mask or blinding factor it's sometimes called. We mix those together in Monero and a lot of other assets. We use Pedersen commitments which I show how that works there. It's some commitment blob that's actually done using some simple elliptic curve arithmetic, where we have these two group elements, G and H, and we basically throw the value in one slot and the mask in another slot, because elliptic curve cryptography works very well, you get this random-looking blob, the commitment. And you can do things with that. In particular, you can't just look at the commitment and determine the value or mask. The property we call hiding. Very useful.

But we can also show that a transaction balances not like in Bitcoin, where you just look at the values and be like: "Do these numbers add up correctly?" Well, we don't know what the numbers are. They're hidden in commitments. But what you can do is you can still do arithmetic on commitments. That's similar to what you do with values. So what you do is you show the transaction balances in zero knowledge, which is nice, using sums and differences of the commitments of input coins and output coins, and you can provide something like a Schnorr proof to show that it balances. So very simple cryptographic technique. If you've done it before, if not, take my word for it. Works really, really well. We know how to do this. And you don't reveal the values or the masks, but you can show a transaction balances cryptographically.

But what happens if you want to support multiple asset types with independent supplies in a safe way within a transaction? There were some initial ideas with Bitcoin for this in a paper called "Confidential Assets", very generic looking paper. But I had a cool idea for ways to do it. It had some downsides that I won't go into for time reasons, but I'm happy to talk about them later. But in order to do it in the way we're going to, in order to get the goals that we want out of it, we'll do a bit of a different design.

So in this case, we'll have some asset types that we want to be fungible, which means that you have these coins that are divisible and are particularly differentiated. Every coin is supposed to look like every other coin. It's fungibility. But other types of assets, maybe we want those to be so-called non-fungible, where I'll just use the term tokens for those to differentiate them from fungible coins. And these tokens in this case have actual identifiers, because you want them to be non-fungible. An identifier should identify a particular one of these tokens. And in this case, we want them to be differentiated, but only to recipients and other designated verifiers, not on chain. So in all cases, what we want, we want the transactions to be as uniformly, blobs of nothing as possible, and to protect as much data and metadata as we can, until or unless the user chooses to reveal it to a designated verifier.

So, Spats is a protocol that's intended to meet these goals as kind of an extension to existing confidential transaction protocols. So it's not an entirely new thing. What it's designed to do is kind of tack onto something like Spark, like Seraphis, or you could even do it with RingCT if you wanted, but I wouldn't recommend it because we have new things now like Seraphis in order to meet the goals.

And the way we do it, I'm not gonna go into a ton of detail because we don't have a lot of time, but the idea is to take these value commitments where you have the value and a mask and you build a blob of nothing around it. The idea is to extend these commitments to include a little bit of additional data. One of those pieces of data is the asset type, call it a, and the other one is an identifier. I think I call it iota here because i was taken in the paper. And it's very easy to do this with Pedersen commitments. You basically add just new slots into your commitment, one of which holds this asset type, one of which holds an identifier if you use it. And what we do is we define that all assets, whether they're supposed to be a fungible type or a non-fungible type, have a unique asset type. It doesn't have to be random. It can just be anything that the protocol decides. You can just have a counter that increases, one, two, three, four, and so on.

Fungible assets won't use identifiers because we don't want that. The identifier is just set to zero to improve fungibility. But every one of the tokens of a non-fungible type has a unique identifier within that type. And again, it doesn't have to be random. You'll see later the security doesn't depend on that. So you have asset types and you have identifiers and they go together into the coin commitment.

So previously we had a commitment that included v, a value, and m, a mask. And now it looks slightly more complicated by adding those two additional components the asset type a and the identifier iota. So in a fungible asset, you notice we always set the identifier iota in order to be zero to improve fungibility. And for non-fungible asset types, for technical reasons, we set the value to be exactly one. And the reason we do this is because it basically gives us this property that I can't split a token and transfer this non-fungible token in two different ways to two different other users. We don't want that. We want transfers to happen atomically. And it turns out if you set the value v to be equal to 1, well, you effectively can't split that. I can't split 1 into a smaller integer value. I can actually have it be 0, but you'll see later, we might actually want you to be able to identify basically dummy asset types using the value v equals 0. But it's not important right now. The idea is you can represent both of these different types, fungible and non-fungible types, in a very similar framework.

So how do you go through and mint these things? So right now in protocols like Monero, we have coin-based transactions that have defined values that are allowed to be minted at certain times as part of those transactions. And what they do is they reveal the value. Well, they have to reveal the value, because the network needs to be able to verify that the supply is changing at a well-defined rate. So right now, the minted coin of value v can include a Schnorr proof that its commitment is to the expected value that's defined by the protocol rules. But they don't necessarily have to reveal the secret mask m, and that's what protects supply.

So with Spats, you basically just extend this, where you need to know during these coin-based type operations, these mint operations, whether or not a new asset type or identifier that's being minted meets whatever consensus rules you end up deciding. It's up to the implementers. So now, for a minted coin or token, you reveal the type, the identifier, and the value publicly, which you have to so that the network can verify it. That makes sure that the supply is correct across all these different types, whether fungible or not, according to whatever protocol rules you decide to implement.

And what's nice is this still all supports the idea of dissociating the assets from the addresses. So you can still totally do stealth addressing with this, works exactly the same way.

But how do you do things like a transfer or a spend transactions? There's one simple rule. And the idea is that cryptographically, we wanna ensure that all of the consumed and generated assets in a transaction, so your inputs and your outputs, share the same asset type and identifier. Fairly simple rule.

So for fungible assets, as now, we might consume several coins of a different type in order to get all the value that you need associated together. We need to have enough to spend. And you might generate several coins of the same type, including, of course, change as usual. And remember, we set that identifier iota to be zero so that all these fungible assets look the same. 

For non-fungible assets, the transaction is only going to transfer a single token. Remember that token does have a non-trivial identifier iota. So that will be maintained throughout the transactions so that you can prove that you own a particular non-fungible token. So in that case, you can also include some zero value dummy tokens for uniformity. So that's why we include this v = 1 value rule. Makes the rule work out really nicely in this case.

But there's a catch. If you don't have to care about fees, this is just this beautifully simple abstraction. But unfortunately, we do need to care about fees. And the problem is this. How can I issue fees to something like a miner if the asset type is protected? All the miner will know is like, you're gonna get some asset. But maybe they don't care about what that asset is, and you don't want to reveal it at the time of the transaction. And they wouldn't know what it is anyway. So the unfortunate answer is, you can't get around that. So Spats makes a rather unfortunate trade-off by adding a second simple rule. So I lie. There's actually two simple rules. And it's that right now, transactions have a fee side to the transaction that consumes and generates coins of a single base type. So it's like Monero. That would probably be the base asset type if you were to make such an extension to Monero.

So a transaction effectively does two things. It issues fees in a fixed known base asset type that everyone can agree on. And then it transfers on the other side, the asset side maybe, it transfers coins or tokens of some arbitrary unknown protected asset type. So miners don't need to know about that because they ideally don't care. So I won't go through like all the proofs behind this, but I'll give you some slightly gory details about how you actually implement these two simple rules cryptographically.

As always, the answer is zero knowledge proofs. Great, ZKPs. And it turns out you can add some ZKPs into the mix in a totally non-trusted way to be clear, very simple proof structures. On the fee side, you need to show cryptographically that all of the consumed and generated coins are in fact of the base asset type. So what we do is we define the base asset type, again like Monero or some known agreed upon type, to have its asset type just be equal to zero. And I'll explain why that's useful in a second. And also we defined fungible asset types to have identifiers equal to zero. So we prove cryptographically in a nice zero-knowledge way that this is achieved.

And we also need to show that the fee side balances. And again, we already know how to do that. On the asset side, we need to show that all of the inputs, the consumed coins and tokens, and all the outputs, the generated assets or tokens, on the asset side, we don't necessarily want to know what those values are, a and iota, because that would reveal information, but we want to show that they are the same. And it turns out you can do this with some clever zero-knowledge proofs as well. And again, we want to show that the asset side balances. And we do know how to do that using Schnorr type proofs.

So ideally, this asserts that very minimal information is leaked because of properties of these zero-knowledge proving systems. So on the fee side, we want to know what the asset is that we're using, because it's an agreed-upon-based asset. Now on the asset side, we don't want to know what that is, because that would leak data and metadata. So we know how to build these. Each of them is kind of a Schnorr type proof, but that has some really nice properties for scaling. So the size of each of these proofs is completely independent of the number of coins or tokens involved. So the scaling is effectively constant, just like the best scaling. The verification is efficient, and because these are Schnorr type proofs, you can do batch verification, which is pretty solid.

Trusted setups are icky and bad, and we don't want to do them. You don't need any of that. They're very easy to set up. And the security proofs are very straightforward. So no crazy math here, very well understood math. If you care, there's a power of challenge design that's kind of cool that came out of paper and we can adapt it to do this.

So there's also a slight change where you need to modify range proofs just a tiny bit to support vector commitments, but this is very easy to do with Bulletproofs and Bulletproofs+ that adds like trivial changes.

So what would this do to efficiency if this were implemented in a RingCT or Spark or Seraphis type protocol? Well, they require modifications to some of the existing proofs as well as new proofs. So if you care about the details, range proof changes just by a tiny number of bytes, 64. And then we have a slight modification by adding a asset side balance proof, only 128 bytes, not too bad. And then these type equivalency proofs that I talked about, they add a little bit on the base and asset side. So a non-trivial number of bytes, in this case 576 under normal circumstances, but I don't know, maybe you're okay with that, maybe you're not.

And I should say this doesn't include some encrypted encodings of asset types and identifiers that go to recipients which is an extension of how protocols like Monero already do things. But that depends on some protocol rules and transaction structure and is also pretty minimal.

In terms of verification efficiency, the new proofs are really fast. Schnorr type proofs are great for that reason. So there's basically minimal verification complexity compared to other things like range proofs which take longer to verify.

So what about migration, right? What we don't wanna do is have these new pools of coins where we need to kind of start from scratch in terms of input ambiguity. So, Spats does need to play nicely with protocols like Spark or Seraphis or RingCT, and ideally you shouldn't need to do like weird migrations from an asset pool to a new asset pool, since that can leak information and be risky unless you're really careful about it. But fortunately, the design that we chose makes this really, really easy.

So, because I said earlier that base assets are defined to have the asset type just be equal to zero, the constant number is zero, what that does is because of the arithmetic of commitments, that means that all existing coins, before you add this Spats idea to it, are automatically Spats coins too. Like you just get that for free. So that little equation up there is why that's true, because you throw zeros into a commitment, makes certain things go away nicely. That holds between all these new and existing commitments. So that's very solid. You're able to use all existing coins in these Spats proofs.

And because we have these two simple rules that we talked about, enforced using some new ZKPs on coin commitments, it just means that there's always a single pool of assets to be used. You don't have to differentiate between these fixed-based assets, and then your fungible assets and any non-fungible assets. They all belong to the same pool and they all look as much the same as we can get. You're always going to leak metadata and transactions to be clear, but we probably get as close as you can get. What's nice is that means that Spats can support really clean migrations from these existing protocols, were it to be added to such a protocol in the future at any time.

So, last thing I'll kind of hint on is the idea of ownership proofs. So typically if you were to own some kind of serialized, non-fungible token type thing, you probably want to prove that you own it at some point for whatever reason. So what does an ownership proof actually need to do? Well, it actually involves several things if you think about it. You need to show that the commitment, the blob on the chain that you have to your token is representative of the asset type and identifier that you're claiming. So remember that we hide that in a commitment and bind to it in the commitment. But we need to be able to show it cryptographically. We also need to show that you actually control it, that is that you know the secret data that would be required if you were to transfer the token, although you're not gonna do it at the time of the proof. You also wanna show that you're not just replaying the proof to someone as a trick, because if someone hands me a proof of ownership, if I hand that on to someone else, they shouldn't think that I own the token, because there shouldn't be a chain of trust here. Proofs are intended to be used in one specific context.

And importantly, we need to know that the token hasn't been transferred later. Maybe I owned it or controlled it at the time of the chain that you're looking at, but what if I transferred it later? So the first two things on there are very straightforward using additional Schnorr type proofs. If you don't already notice, Schnorr proofs are great. We should use more of them.

The third thing about proof replaying, it turns out is also very easy cryptographically. There's a thing called Fiat-Shamir message binding. It's already used in a ton of different protocols. Basically means that you can throw some kind of context specific message into a proof, and the proof will only verify if that message matches. So there's ways that like a prover and verifier can challenge each other really easily. Very straightforward to do, incurs like no performance overhead at all.

But that last thing I said there, the token has not already been transferred everywhere. That is where things get hairy. This is what I don't like, which is why this is work in progress. So showing that a token hasn't been transferred since I showed you the proof and you checked it, that's much trickier.

One approach that I do not like is the following. So tokens, much like you have right now in protocols like Monero, protocols like Zcash, have it too. They have something akin to a linking tag or a nullifier or a key image, and everyone's got a different word for this. But it basically is a representation in a hidden way of what a coin is. As you know, if a transaction reveals a linking tag key image or whatever, then it can't reveal it again without indicating that a double spend attempt has taken place.

So one approach to doing these ownership proofs is to effectively reveal to the verifier of the proof what the linking tag is. I also need to prove that I didn't hand you some random garbage that I actually generated the linking tag correctly. That's straightforward to do. And you, the verifier, can assert that the tag that I handed you, which has been generated correctly, does not appear in any subsequent transaction, which would indicate that the token had been transferred. So if it doesn't appear anywhere in your view of the chain as the verifier, then the prover still controls it.

Fortunately, this sucks because if the verifier has the linking tag, even if the token hasn't been transferred yet, they can just hold onto that tag and watch to see if or when it appears on chain, which would indicate that the token had later been transferred. Now the verifier can't actually tell where the token went or anything, but it does leak important metadata, and that is not good.

So a better way would be to prove that the tag doesn't appear on chain without revealing it, and you need much more clever proof techniques that would not scale quite as well, and that's still very much a work in progress. But ownership proofs would be nice, so if you were to implement this, with token support, you'd probably want that. Like I said, it's possible just to do like the fungible asset stuff, in which case all these questions go away and you don't have to care about what it just said.

So the gist of this is that Spats is a new design we came up with to do user-defined confidential assets and optionally tokens as well. It's got some really nice properties. So you can support fungible and non-fungible asset types in a very uniform, clean way. You can make transactions pretty uniform despite having all these new features. You can protect asset types, identifiers, and values so they're not leaked in transactions except to recipients and designated verifiers. You can do fees in a fixed base asset type, which probably makes miners happy or other similar users of the system depending how you set up your protocol. You can prove token ownership, albeit in a very leaky way that you'd love to make a lot better. The proving systems are very straightforward, very easy to show security for, pretty efficient. The migration is very, very clean. You don't have to start weird new pools that you have to transfer tokens and coins over to. And all the coins and tokens can just share one big single pool, regardless of whether they are a base asset, some other non-based fungible asset, or a non-fungible asset.

So there is a preprint for this. It's on the IACR preprint archive, and the preprint is also on a GitHub repository, so you can see how it's evolved over time. These slides, if you want them, are also up there. And that's my email too, if anyone wants to get in touch. So thank you very much for your time.