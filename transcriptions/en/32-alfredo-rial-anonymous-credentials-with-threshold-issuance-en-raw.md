# Alfredo Rial

_**Anonymous Credentials with Threshold Issuance**_

[https://youtu.be/lFyyJkxb49A](https://youtu.be/lFyyJkxb49A)

---

_**Alfredo:**_ Thank you so much for the introduction, and it's a pleasure to be here, and thank you all of you for coming to this presentation on Sunday morning. So it's a pleasure.

So yeah, in NYM we provide privacy at the network layer by using a Mixnet. But in addition to that, we also provide privacy at the application layer by using anonymous credentials and anonymous e-cash. And in this talk I am going to focus on that part, on providing privacy at the application layer.

So first of all, I will describe briefly what anonymous credentials are. I'm sure many of you are already familiar with the topic, but in any case, I will do a brief introduction.

So you can think of a credential as the digital counterpart of a physical credential, like a passport, identity card, driver's license, etc. Basically, a credential is something that certifies that you possess certain attributes — your nationality, your name, your date of birth, etc. So a digital credential is basically a signature. Somebody certifies that you possess those attributes and provides you with a signature that signs those attributes.

Now, if we use just signatures to implement anonymous credentials, then we would have a scheme that is not privacy preserving. The reason is simple, it's just when you want to show your credential, you disclose all your attributes. So, for example, if we have a credential verifier, like a service provider that needs to verify that your age is over 16, if you just present your signature, then to verify that your age is over 16, that verifier need to check, need to see all your attributes, basically. That's why we need anonymous credentials. Our goal is that when you want to show your credential, you only reveal to that verifier that your age is over 16 and no extra information, not even your credential itself, only the fact that your age is over 16 in this example, right?

So, to create, to design an anonymous credential scheme, we need to implement the idea of using digital signatures with two protocols, basically a Show Protocol, which we have here, and also a Blind Issuance Protocol. So first, with the Show Protocol.

As in the example I was describing, if we just send the credential, the signature, then we would need to disclose all our attributes, and the verifier would learn all of them, right? So basically here, what we use in the Show Protocol is a zero-knowledge proof. What we do is to proof possession of our credential. So using a zero-knowledge proof of signature possession, what we do is that we take our credential, we create a presentation token, which consists basically of this zero-knowledge proof and includes a proof that the age or date of birth on our credential is such that your age is over 16, but doesn't reveal any more information about your other attributes or even it doesn't reveal your age or date of birth itself, right? And with this Show Protocol, we can provide privacy towards the credential verifier.

And then apart from that, we also have an Issuance Protocol where — I mean, you could think that in principle, the credential issuer needs to learn all your attributes in order to verify them, right? Like it needs to attest your date of birth, etc. But there are cases in which this is not necessary. For example, imagine that you already possess an identity card that already has certified your attributes, etc., and then you need another credential verifier to issue you another credential that also contains those attributes. Then what you could do is to basically prove in zero knowledge that you already have that other credential issued to you, and then the credential issuer doesn't need to learn again all your attributes. It can simply sign the attributes that were already signed previously and provide you with the new credential. And this is our case in NYM. So in NYM, we don't need to learn your attributes, we trust that you already possess a valid passport, etc. I mean, we don't trust that we verify that you already possess it, you present your attributes in zero knowledge, and then we recertify your attributes providing a new credential.

Okay, so basically, probably you already found out what the basic security properties of anonymous credentials are. In the case of the Issuance Protocol, we have blind issuance, which means that some attributes, you can get them signed by your credential issuer without the credential issuer learning them. This is flexible. Some attributes the credential issuer may need to learn, some others not. And also you can prove in zero-knowledge statements about your attributes. For example, that they have been signed before.

And in the Show Protocol, we have unforgeability, which basically means that a corrupt user is not able to produce a presentation token for a certain access control policy if he doesn't possess the credentials with the attributes that fulfill the access control policy. And also we have unlinkability, which is the property that gives us privacy and anonymity. Basically, unlinkability means that if you present your credential, produced two presentation tokens to present it to two different verifiers or even to the same verifier at different times, those presentation tokens are unlinkable. And even if the verifier colludes with the credential issuer. So even if the credential issuer and the verifier were the same person, they wouldn't be able to link the issuance of the credential with the showing of the presentation token. And these properties, I mean, they hold and they provide the privacy that is needed to protect user privacy in the application layer.

So most anonymous credential schemes, anonymous credentials have been proposed in the last two decades. There are different schemes, but up until recently, all these schemes considered one credential issuer, which is trusted in providing a correct certification of your attributes. So the idea is that the user goes to the credential issuer. The credential issuer certifies that he possesses this date of birth, this nationality, etc., and then provides the credential. This creates a single point of trust that if the credential issuer is corrupt, then the credential issuer is able to provide fake credentials to different users, right?

So in NYM, we want to avoid this. And recently, there are some anonymous credential schemes that have been proposed and that provide threshold issuance. So basically, by threshold issuance, what we have is that instead of having only one credential issuer. We have N credential issuers and the idea is that the user needs to interact and obtain a credential share from all those credential issuers in order to obtain a valid credential in the end. So the user would obtain a credential share from at least a threshold number, t lower than or equal to N credential issuers and then once that's done with an aggregation algorithm, the user will aggregate all those credentials and obtain a valid credential that is verifiable with the public key of the system.

So, as I said before, a credential is based on a signature scheme. And in this case, we are going to provide, in NYM we use a credential scheme that uses Pointcheval-Sanders signatures. So, briefly I will describe a bit the scheme. I will not describe in full all the details of the credential scheme, but to understand a bit the most important parts, I need to describe a bit how Pointcheval-Sanders signatures work.

So there is a setup algorithm that produces a bilinear map specification, so the description of the bilinear groups and two generators. And then there is the generation of the public key and the secret key. So basically, here the secret key consists of two elements in the exponent. And the public key, as you would expect, is g to the power of x and g to the power of y.

Then what's more important here is to compute a signature. As you can see, our signature is rather simple. So if we want to sign a message m, basically we pick a random generator and we do this computation. Now I am describing here the version of the scheme, which only considers one message. In practice, we use a version of the scheme that allows you to sign several messages. But here for simplicity, I am just describing the version with one message, right? And for verification, basically you verify that h is indeed a generator and you verify that this has been correctly computed.

Now what's important to know is that this generator h needs to be random and it also needs to be unique for each message that it's signed. So for the scheme to be unforgeable, this scheme is based on an assumption that was created ad-hoc to present in the scheme. Now, there has been already some studies on this assumption that provides, I mean, it's proven in the generic group model that it holds, and there have been several studies and several developments of the assumption that ascertain that it indeed holds.

Right. So now we're using a credential scheme that is based on Pointcheval-Sanders signatures. And first, in 2019, there was a threshold issuance and an anonymous credential scheme proposed, which is called Coconut. And our scheme, the one we're using, is based on Coconut.

Basically, our credential scheme possesses four phases. There is a key generation algorithm in which, instead of having an algorithm that creates the key, now what we need is a threshold issuer, so its credential issuer will get its own set of the key, and this is done through this algorithm. Then we have a blind issuance protocol, like I described before in the first slide. Also, an aggregation algorithm, so when the user obtains all credential shares, it will obtain the credential that is verifiable with the public key of the system. And finally, the Show Protocol.

Now in Coconut, they proposed threshold issuance, anonymous credential scheme that has a bit, well I wouldn't say problems, but two issues, which is that privacy doesn't hold unconditionally, it holds by using a computational assumption. So we did some modifications in Coconut so that both the blind issuance property and privacy in the Show Protocol, so the synchronous property hold under no assumptions or information theoretically or unconditionally. And also when doing that, we were able to improve the efficiency of the scheme. And this is described in our paper, which also describes the security analysis of the credential scheme.

First, as I said, we replace the key generation algorithm by another algorithm that computes for each user the share of the key. Basically, we use Shamir's secret sharing. I'm sure most of you are already familiar with Samir's secret sharing. Basically, in the case of the scheme that only signs one message. We have two random polynomials that are created, and then we evaluate those polynomials and times to compute each share of the key. And finally, we compute the public key shares as usual. But only here we add another element in the public key, in the group g, also in the group g tilde. And this is done for what I said before, to improve the privacy of the blind issuance protocol. Later I will show how this element is used to provide privacy and blind issuance that holds unconditionally.

And now if we use this algorithm, then you would need a trusted party that runs it, because the trusted party, the party that runs the algorithm would know all the shares of, all the secret key shares of all the credential issuers. So instead what we do is to use a distributed key generation protocol, and the protocol we have implemented is based on the protocol by James Groth, so "Non-Interactive Distributed Key Generation and Key Resharing", which we did a few modifications, but essentially the protocol is the same.

Now, so how does the Blind Issuance Protocol work? So the idea is that in the Blind Issuance Protocol, we have a user that inputs a message and it needs to interact three times with the credential issuers to obtain the credential shares. So in each of these interactions with one credential issuer, the credential issuer inputs its own key share. And as output, the user will obtain the credential share, which is basically a signature, a Pointcheval-Sanders signature of the message using the share that the credential issuer possesses.

Now, the main difficulty to create, to design this Blind Issuance Protocol is that, as you saw in the previous slide, there is this generator h that needs to be unique, random, and then all the credential issuers would need to agree on a common h, but without communicating between them. So the way this is done is that h is picked up by the user this way. First, the user computes a Pedersen commitment to the message, and then it computes h as the hash of this Pedersen commitment. Now, if we model the hash function h as a random oracle then we can prove that h is random, and also the binding property of the Pedersen commitment guarantees that each h will be different for each signed message. And then to provide the blind issuance procedure, the user computes another commitment to the message by using h as generator in the Pedersen commitment. Finally, there is a serialized proof that proves that all this is correctly formed.

And then once the credential issuer receives this request, it will produce a response that uses in its computation the secret key, the share of the credential issuer. So this response is received by the user and the user will use the randomness, the opening of this commitment to unblind the response and obtain this credential share which is the same as here, right? And here is where we used the new element of the public key in order to unblind this. This is why we need it. But before, the previous version of Coconut used here an ElGamal encryption and that's why they needed, I mean, they proved privacy by using a computational assumption. We replaced ElGamal by a Pedersen commitment and then we are able to unblind using the extra element in the public key and overall efficiency is improved and privacy is also improved because it holds unconditionally.

And after the user obtains all credentials, so at least the credential shares, then he's able to compute a credential verifiable with the public key of the system by using basically Lagrange interpolation. So as usual, you have the credential shares and with using Lagrange interpolation, you can get a credential that is verifiable with the secret key of the system, which is the evaluation of the polynomials at zero. So we'll interpolate at zero.

And now, the Show Protocol — I'm not going to describe it in full detail, but just say that in Coconut, there was already a Show Protocol, which was an improvement. So in the original Pointcheval-Sanders signature paper, there was already a Show Protocol that was a bit inefficient. In Coconut, there was already a Show Protocol that was an improvement, but whose privacy also holds under a computational assumption. And we did a further modification of this protocol in Coconut so that unlinkability now holds unconditionally, so the serialness property is unconditional, and also efficiency is improved, although, I mean, it's a small improvement. But all the details are in the paper I showed before.

Now so far, I've been talking about just the threshold issuance, anonymous credentials, which we could use to provide privacy for access control, basically. But now we also want to have anonymous payments, right? And it is possible to use anonymous credentials, modify them, adding two extra capabilities to just have anonymous e-cash, right?

The idea would be to have a protocol with threshold issuance. We have a protocol where there is an issuance phase. Now I called, since this is e-cash, I called the credential voucher, right? But basically it's again a signature that can sign the amount of money that is withdrawn. So in the issuance phase, the user withdraws a voucher and using the aggregation algorithm would obtain the voucher itself and then it would compute a payment, which is basically a proof of signature possession, that he possesses this voucher. And finally, the service provider would obtain this payment, would verify it, and would deposit the payment with the authorities to obtain back its cash, right?

So what is missing here is that, of course, if the user just is able to spend the voucher as many times as he wants, he would be able to basically use the voucher forever. So we need some mechanism to avoid double spending, right? So that is one of the things we need to turn threshold issuance, anonymous credentials, into anonymous e-cash.

And the other thing is the problem of paying the exact amount. The issue is that in anonymous e-cash, if we want to exchange our e-cash by a non-privacy preserving cryptocurrency or even fiat currency, then this deposit phase is not anonymous, right? Because we need to convert the e-cash to this currency that is not anonymous. So when we deposit it, we lose our anonymity. And for this reason, when a user pays to a service provider, then the service provider cannot give change, because if it gives change, then the user would need to deposit that change and it would lose its anonymity. So the user needs also to be able to pay the exact amount. So to achieve — I mean, this is only in the case that we want to convert to a fiat currency, to a non-privacy preserving cryptocurrency, if we were going to convert again to e-cash, for example, then this could be done anonymously. So basically, we have to solve these two problems, the problem of double spending detection and the problem of paying the exact amount.

So to solve the problem of double spending detection, what we add is a serial number to each of the vouchers. So its voucher, in addition to signing the amount of money in the voucher, it also signs the serial number. The serial number is unique and chosen by the user. And when the payment is computed, the payment reveals the serial number. The service provider verifies the payment and then when it deposits the payment, the authorities would need to check that this serial number is unique and it hasn't been used in previous payments. So for that we can use in general a bulletin board that contains the serial numbers of previous payments. And for implementing that bulletin board we can integrate it with the blockchain which will convert our crypto token to e-cash and then back e-cash to our crypto. So we can use the same blockchain also to store all the bulletin boards.

And finally, to solve the problem of paying the exact amount, what we do is a generalized issuance protocol in which, for example, if you want to pay 30 and you have a token of 50, then you can split it into a token of 30 and a token of 20 by spending the token with the credential issuers, and then the credential issuers issue you a token of 20 and a token of 30. But without learning the amounts that you have spent or the amounts that you have received. So basically what we do is to prove in zero knowledge that the amount of tokens that you have spent with the issuers equals the amount of tokens that you received from the issuers.

And so far, this is the last slide, so I was talking about anonymous online e-cash, which basically means that the service provider in order to verify that payment is valid needs to contact the authorities to check for double spending online before accepting the payment. But there is also offline e-cash, which allows the service provider to accept the payment without contacting the authorities. And this is done by enabling double spending identification. So there are double spending tags in the payment, and only if the user double spends, the authorities are able to receive the identity of the user.

So we have worked on threshold issuance anonymous offline schemes. And next month I will present at PETS our work. So yeah, I mean, there is already an e-print of our paper, but it will also be presented next month in PETS.

Yeah, so thanks all for your attention.
