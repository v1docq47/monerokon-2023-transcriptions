# Elizabeth “noot” Binks

_**ETH-XMR Atomic Swaps**_

[https://youtu.be/p79BveGg288](https://youtu.be/p79BveGg288)

---

_**Elizabeth:**_ Thanks for coming. I’m Elizabeth. I’ll be talking about ETH-Monero atomic swaps today. So a little bit about me. So I’m a software developer. I’ve been working on ETH-Monero atomic swaps for the past around a year and a half. And I’ve been working in general on blockchain protocol level development for five years or so.

Today I’ll talk about the state of the swap. A little bit about the overview and the architecture. A little bit of how to use it if there’s time, and then the roadmap for the future.

So just a little bit of background on atomic swaps. So basically it’s a p2p and trustless way to swap two native assets between different chains. So the ones that are implemented in this case are ETH and Monero. And then “atomic” means that either the swap is successful, so both parties receive their respective funds that they want to receive or they both get their funds back. And this is kind of like cryptographically guaranteed by the protocol.

So on the progress. So this has been deployed on mainnet for around two months now. Yay. So yeah, that’s it. So feel free to go try it out and use it. I’ll have the GitHub link and stuff in later slides.

So right now, what’s my next slide? Yeah, so I guess huge thanks to first the community for funding the actual CCS, and also MAGIC for organizing and assisting with the second funding round, and also thanks to all contributors to the code base and just everyone who’s tried to play around with it so far.

Okay, yeah, I guess I’ll talk about more about how the architecture looks like later. But I’ll go into how the protocol actually works first. I guess this will be the most technical part of the talk.

So say we have two parties, Alice and Bob, and then we can say Alice has ETH and wants Monero, and Bob has Monero and wants ETH. So the swap has a p2p network built in, so Bob will put up an offer on the p2p network, and then Alice can then find it. This was kind of like implementation specific. You could have other mechanisms to find an offer, just like having a website or something like that. So Alice then takes it and then the swap is initiated. And then each party has a secret value. So you can say like Alice’s secret value is x_a and then Bob’s is x_b.

So for the success path, I hope this is large enough, but for the success path at the start, Alice has to lock the ETH first, so there’s a smart contract deployed on Ethereum, which Alice locks the ETH in it. Alice also provides commitments to the two secret values in that when she does that lock step. And then Bob sees the lock and then confirms that, I don’t know, the commitments are correct in that kind of thing and the value, and then locks the Monero in an account on the Monero chain where the private key is the two secrets summed together. Sorry for that - I need to fix that notation, sorry about that. But it’s the two secrets summed together. And then, basically at that point, Bob or Alice will see the lock on Monero because she knows what address is gonna be locked in. And then she’ll call a function in the contract that basically says: okay, Bob can now claim from the contract. And then alternately, say Alice doesn’t see the lock for whatever reason, or she goes offline, there’s a timeout as well that will just automatically trigger and then also allow Bob to claim. So then once the contract is essentially ready for Bob to claim, he’ll just call a claim function on the contract that the input is the swap secret. And then when he inputs that, it will then just transfer these to him. This is like the atomic part essentially. So when Bob reveals his portion of the swap secret essentially, Alice will now know the private key to the account that Monero was locked in and then she can now go do whatever she wants with that. So that’s the atomic part essentially.

So there’s two possible refund paths as well if something goes wrong. For example, like someone goes offline. Both parties do need to remain online essentially for the duration of the swap.

So the first refund path is that Alice locks ETH and then Bob just goes offline and then doesn’t ever lock the Monero. So what happens in this case is that, so I mentioned earlier there was a timeout in the contract, so when that first timeout is passed, that means Bob can automatically claim. So basically Alice will wait until this timeout is getting close. And then if, no Monero has been locked and that timeout is getting close, she’ll just call a function on the contract that will refund the ETH. And this refund function is similar to the claim function in that it takes Alice’s swap secret. So in the case that Bob did lock for whatever reason, but just Alice didn’t find out, then Bob will still be able to refund as well.

And then the second refund path. In this case is that the case that Bob never claims the ETH. So the first step is the same as the success path. Both parties successfully lock, and then the contract becomes ready, but then Bob just never claims for whatever reason. So there’s a second timeout as well, where basically after the second timeout, the only possible move is that Alice refunds, and that Bob can’t claim as well after the second timeout. So basically Alice will just watch the contract and then see that essentially nothing happened until the second timeout, also then call refund similar to before passing in her swap secret. And then say, for example, say this is because Bob went offline or something will come back online and then will check the contract see that there is the refund transaction, find out this top secret and then be able to regain the Monero that was locked.

So that’s basically the protocol. There’s more docs on this as well on the GitHub repo, or feel free to ask questions after.

So I guess road to mainnet. So a little bit about what was implemented, for the actual implementation. So the protocol itself is relatively simple and straightforward to implement. But when you’re actually trying to put it into production, there’s a lot more to consider. For example, what if someone stops swap node while in the middle of a swap or something like that. How are they going to recover and how are you going to find out what steps they’re at? Make sure they don’t lose the swap secret and that kind of thing.

The first thing here is database and restart safety. Essentially you want in case the node shuts down at any point, the user should be able to recover all the data.

Also built-in Monero wallet handling. So in first iteration you had to run Monero wallet’s CLI separately, but that was a little bit not user friendly. So now it’s built in. It just starts it and handles it for you. And then it’ll automatically send the funds where you want them to go at the end.

There’s also a relayer system. So due to the way Ethereum works, you essentially need to pay gas for every transaction. But, for example, say you’re Bob and you don’t have any ETH, but you want to get ETH. Then how are you going to pay for gas, essentially? So the relayer system fixes that problem. You basically get someone else to pay gas for you, and in exchange they get a little bit of the swap funds.

There’s ERC20 support as well. So there’s token support. And then generally bug fixes, UX improvements, testing, and then also a dedicated bootnode program. So I’ll talk about that a bit more later for people joining the p2p network.

So a little bit about the p2p network. So the program uses a library called libp2p, which is sounds like it’s just a peer-to-peer library. So it comes with a bunch of nice features already built-in. So you have NAT traversal if you’re behind a NAT. It has a DHT for peer discovery. So it’s entirely p2p and permissionless and decentralized. So you can just run a node and join and like offer discovery is also entirely like p2p and decentralized as well.

And then, yeah, I kinda talked about this already, but essentially everything, for the database and restart safety, everything or all this information that you need is actually stored on disk now. So then if anything happens during the duration of the swap, you should be safe to restart it.

And then relayer system. So another aspect of the relayer system is that it’s also bad for privacy if you have to withdraw the ETH into an account that’s already been used or wherever you already have ETH in it. So the relayer system is just a good improvement for both privacy and UX. So kind of how this works is that the relayers also advertise their services on the p2p network, similar to how people who are making offers also advertise them. They’re paid a portion of the swap value in return.

So if you need a relayer, you can basically, like, in the program, it’ll just automatically, like, search the p2p network and find one for you. So how it works is essentially, like, Bob will sign a transaction, the claim transaction, and then the relayer will submit it on their behalf and pay the gas. And then the contractor will check the signature and that kind of thing, and then transfer most of the swap value to Bob, and then, like, a little bit to the relayer as the fee. So then now you can withdraw to a fresh account, which is nice.

So yeah, this is basically the same as the success path, except in the part where Bob is claiming. Yeah, he’ll search for relayers. Say you find one named Charlie. So Charlie has to send his payout address, where the relayer fee will be sent to. And then Bob will sign the claim data, which includes this payout address. So this is essentially like to prevent front running. I found that during testing and that was fun to deal with. So yeah, that was front running protected.

So additionally, in addition to market makers, like relayers are really essential to part of the system. Otherwise, it just becomes a bit of a pain to use, I suppose. So right now, it’s permissionless. Yes, it’s for persons who just join I’d highly recommend running one if you want, because you don’t need any Monero. You need only a really small amount of ETH just essentially to pay for gas to start off. And you get a little bit of funds. So I would recommend running one.

So went through two different designs for this. So originally went with a meta-transaction compatible design, but a lot of these are all in JavaScript. So kind of didn’t like that, because the code is written in Go. So I ended up implementing our own little system, which is a lot cleaner, actually. But in the future, may move to EIP4337, which is “account abstraction”, which is kind of standardized relayer system you could think of. Yeah, but it wasn’t super ready at the time of launch, so maybe in the future.

And then last thing, or one of the last things - bootnodes. So they’re used as an entry point into the p2p network. So every p2p network needs to have hard-coded addresses that the node will connect to on startup to enter the network. Otherwise, I don’t know, you just can’t get in. So yeah, they have to be publicly known or hard-coded. And also another thing is that it’s also recommended if you wanna run a bootnode. So you can just run one. You don’t need to have any funds. You don’t need to do anything. It’s just you’re literally running a node that helps with the decentralization of the system, just because more bootnodes is better in case any of them go down. So if you want to contribute, but you don’t want to actually do any swaps or anything, you can also run a bootnode.

Okay, and then a few commonly asked questions that I get. So the first is, can the swap work on chains other than Ethereum? So yes. So it can be deployed on any EVM chain. So there’s a smart contract, like I mentioned, and you can deploy this on any EVM as is essentially. But then also, if you want to deploy it on a non-EVM chain, you could rewrite the contract in whatever smart contract language that that chain is supporting. So yeah, there’s currently only the ETH solidity implementation, but you could theoretically deploy it on any smart contract chain on one side, then Monero on the other side.

And then another thing is that why can only Monero holders be market makers? So as you might have remembered in the first protocol step I showed, so it requires the ETH holder to lock first. So basically why is there this kind of one-way limitation? So essentially, there’s no refund capability on Monero - the main problem. So this forces the ETH holders to move first because, say the Monero holder moves first and then lock, and then the ETH holder never does anything, how are they going to refund? They can’t. Therefore, the ETH holder needs to move first in the protocol.

However, if, say, you have the ETH holder market makers, i.e., they put up offers on the network that can be taken, they can be griefed. So what this means is that since they move first and they have an offer up, someone can just come take it, force them to lock, and then force them to refund because they don’t actually do anything, and then therefore the ETH holder will lose a bunch of gas because it’s comparatively much more expensive to do all those steps. And then someone can do that without having anything at stake because the ETH holder moves first.

So that is kind of the one way limitation right now. So that only Monero holders can put up offers on the network. But yeah, there is hopefully maybe some ways to get around this. Kind of in research. So yeah, so if, obviously, if there’s any more questions, feel free to ask after. But hope that explained things.

Yeah, I think I have enough time for this. So I’m just gonna show like a little bit of how it looks to run it. So right now it’s a CLI only. So if you’re comfortable with the terminal, that’s good. We tried to make it really easy to run though. So hard to mess up. So even if you’re not familiar with the terminal, I’d recommend trying it.

So first you just build it, and then you just run the swapd binary, and then you pass in an Ethereum endpoint. So you can run your own node these people like remote endpoints. So yeah, whatever. So this will just run it and then it’ll automatically connect to the mainnet network.

And then you can also check your balances. So the swap node contains an ETH private key and Monero private key in a wallet. So you can check your balances. You can easily deposit funds as well. There’s QR code in the terminal kind of cool. Yes, you can deposit, and there’s also commands to withdraw easily so it’s basically a whole wallet in the program as well.

So then when you want to make a swap, or sorry, when you want to make an offer, you can just do swap CLI make and then your parameters, so how much you want to put as the offer, your exchange rate, and then the program also has suggested exchange rate from an oracle. Obviously, double check it, but it’s there.

And then once you’ve made it, you can see the offer ID and that kind of thing. And then to search the network for offers, you do swapcli get-offers, you can see offers on the network. And then when you see one you like, you can… so this is also… oh sorry, this one is for getting your own offers. And this one is for checking for the offers on the network. So this show you offers. And then when you like one, you can just do take and then pass the offer ID, the peer ID, which is the remote nodes, p2p ID, and then the amount that you’re gonna provide in ETH, and then it’ll start the swap, and you can check your ongoing swaps as well. It was just the ongoing command. And then you can also check your past swaps with the pass command. And that’s basically it.

I don’t have it down all the time because I didn’t think there would be enough time, but if you want to check my Monerotopia talk from last month, you can see how it works in practice.

So a little bit of the roadmap for the future. So one thing that I definitely want to add is built-in network privacy. So like I mentioned, it uses the p2p library, but there isn’t really a good built-in privacy transport for it yet. Ideally, we’d like to add that via Tor or Nym or something like that.

Dynamic relayer pricing. So right now, the pricing, like the fee that’s received when you do a relay is essentially fixed. But if the gas price pumps a lot, this is bad because you won’t get as much in reward, essentially, because the gas will go up. So essentially making that dynamic. Yeah, gas has been somewhat stable lately, but in the case it goes up, we want to increase the relay fee.

And then a browser UI. So there is sort of a UI you can run right now that’s self-hosted. It doesn’t work great, but essentially, it just hasn’t been maintained as much. But essentially, we’d like to implement a browser UI that you can just run either locally or, I don’t know… Ideally, you don’t have to run it locally, but that’s a lot more complicated. So you can use MetaMask a browser wallet or anything like that to do the swap. So you don’t have to deposit your funds into the CLI you can just use your normal browser wallet kind of methodology. And then just testing, bug fixes, usability that kind of thing.

So in summary, it’s ready for use. We need Monero providers. We need liquidity providers. So if you want to be one definitely reach out. We need relayers and more bootnodes will always be good as well. So this is the GitHub. So it’s AthanorLabs / atomic-swap. And then there’s also a matrix room - ethxmrswap. So if you want to check out the GitHub or reach out, feel free to do so. Okay, that’s it.
