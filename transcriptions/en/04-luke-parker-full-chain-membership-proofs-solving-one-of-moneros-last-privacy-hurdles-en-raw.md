# Luke Parker

_**Full Chain Membership Proofs: Solving One of Monero’s Last Privacy Hurdles**_

[https://youtu.be/vrCAiLPfXlg](https://youtu.be/vrCAiLPfXlg)

---

_**Luke Parker:**_ Thank you very much. So happy to finally be up here. Happy to also have my slides while I’m up here. Today I’m presenting on full chain membership proofs, one of Monero’s last privacy hurdles.

So just to start with, who am I? I like to just give a brief introduction before all my talks. Luke Parker, Kayaba, or kayabaNerve. If you see them online, it would have been under one of these names. I’m a developer and an informal cryptographer. I’m not here to write your papers. I’m not here to do the security proofs. I am here to write implementations and do my best to make them as fast as possible.

I’ll try to make this not happen again. I’m also the lead developer of Serai, a decentralized exchange, which will be launching with Bitcoin, Ethereum, and Monero, so that’s something to look forward to in the future.

I am a MAGIC Monero Fund Committee member. MAGIC is a 501c3 charity. The Monero Fund is a Monero focused committee which aims to fund Monero research and development. And if you donate to it, it’s US tax deductible, so always a fan of shilling it.

And then finally, I am a servant of the Monero community, hence the outfit today.

So just to get everyone up to speed, what are full chain membership proofs? Full chain membership proofs are replacement for ring signatures. They, instead of just having 16 outputs, you’d have the entire chain as one of the possible outputs you’re spending. And accordingly, they’d remove technically not all, but most of the statistical analysis possible on inputs.

Justin Berman, one of my fellow servants of the Monero community - friendly reminder, no photographs within the venue unfortunately - they’re doing a great talk later today on the privacy of the current. Well technically their talks on light wallets, but as part of it they go over the privacy of the decoy model, so I recommend their talk.

But full chain membership proofs would solve the EAE/EABE/overseer tax, which were in an episode of Breaking Monero. And they’d also solve some other attacks, such as the tainted dust attack and so on.

Full chain membership proofs are being proposed as part of Seraphis, the next protocol upgrade for Monero, not as a replacement too. So don’t go like: "Oh, we’re getting rid of Seraphis". Nope, this is part of Seraphis.

And it would remove needing a decoy selection algorithm. And this is one of the favorites of Justin and us, because these algorithms are a pain. We have spent a lot of time researching them. We have spent a lot of time working on them and we’re still putting time into bug fixes to this day. And if we move to full chain membership proofs, we don’t have to still focus on them, which is really nice as developers.

So when we discuss doing full-chain membership groups, we’re generally discussing a very specific academic proposal known as Curve Trees. Curve Trees uses as a pair of Bulletproofs to prove that the output exists in some tree of outputs. The reason this is significant is we’re not discussing, you know, some trusted setup, Ethereum, ZK proof. No, we’re literally discussing tech that’s already in Monero Bulletproofs. We currently use it to verify outputs, as my next bullet point says.

And despite using them to currently verify output amounts are valid, we can use them for arbitrary programs. So as part of using them for arbitrary programs, we can use them to say: "Yep, this output exists somewhere on the chain".

The one issue with Curve Trees, which is why we haven’t prior discussed it - well, we have prior discussed it, but when we initially saw it, we kind of weren’t as amenable to it - was because it requires a curve cycle. Curve cycle is this mathematical arrangement. Monero doesn’t have it. So then the question is - how would we obtain a curve cycle? We don’t have a curve cycle now. How do we get to one?

Seraphis is kind of the perfect opportunity for this. With Seraphis we have to recreate all addresses. And the reason we’re willing to do that with Seraphis is because Seraphis is worth it. It brings a lot of improvements. Currently, Seraphis has been discussed as taking us from 16 ring members to 128 ring members. It’s a massive improvement in that regard. And it also has a lot of functionality is distinct. It’s not just about increasing the ring size, it’s also about offering outgoing view keys, which is something I have desperately missed in my work with Monero.

So since Seraphis is already throwing out all the existing addresses, if we switch elliptic curves, you know, kind of the mathematical underpinnings of Monero, it’s not gonna be that notable. We’re already throwing out the old cryptography. Why don’t we just throw out a bit more of it?

Chase, Orru, Perrin, and Zaverucha, sorry if I’m mispronouncing any of those names, released a proof in 2022 that lets protocols move between elliptic curves. So because of this proof, which came out last year, It’s not just: "Oh cool, let’s throw out cryptography with all the issues of that", but no, we actually have a way to do that while still being private and never revealing amounts.

Technically, we can implement Curve Trees without a cycle, but it would take roughly half the performance, which is why I’m really pushing for us to move to a curve cycle with Seraphis.

And then if we don’t move, not only is it going to be half the performance, but we’re going to have to maintain these four libraries for the rest of our lives. Right now we have the ED25519 curve. That’s what Monero’s cryptography is built upon. If we don’t move to a curve cycle, which would be two different curves we’re going to have to maintain ED25519, another library, and then two more libraries for the curve cycle. So basically, if we don’t move to a curve cycle, we’re halving our throughput, and we’re doubling our development load, and it’s just all such a pain. And Seraphis is just the perfect opportunity to do so. I do think this is the most technical detoxing to get, if anyone here is concerned about that.

So now the question is how do we actually implement this? We’ve talked about full chain membership proofs, I believe, for roughly a year now. Notably, Seth opened a GitHub issue, Seth For Privacy, they opened a GitHub issue about this year ago, and it’s something that’s been discussed since 2018. I believe I was looking at old MRL issues, and I noted one saying: "Sarang and Serai were going to review embedding stakes in the Bulletproofs years ago", and the academic theory on that too sort of offer these solutions. But obviously, it was here in 2023. That didn’t happen. And now the question is, how do we move forward?

Which is why I’m happy to announce I’ve already done that. I’ve actually implemented all of the proofs discussed from Curve Trees to the COPSI membership proof to even the new elliptic curve cycle that we’re currently is our best candidate for moving to.

It’s cleanly written because this isn’t just meant to be a proof of concept, this is meant to be something that I can give to the Monero research community as a whole and they can take and actually harden it on it and see deployed. This isn’t just another research proof of concept or some Python dummy code. So it’s actually ready to start discussing building around today and there’s plenty of people here I’d like to do that with.

As for performance, that’s obviously the major question. We can’t exactly take ten seconds of transaction. Right mow - sorry, this is a technical note - when you verify one of these proofs, there’s two steps. There’s the batch verification. You can take 10 proofs and verify them all at once. But there’s also the preparation. You take an individual proof, you prepare it, and then it’s sent to the batch verifier. So there’s two different segments there. And I think that note’s irrelevant, because I actually think I deleted the distinction from the rest of my slides. So I apologize for that.

But basically, proofs are verified in a batch and it’s taking 100 milliseconds right now. But that would give us 777 million outputs, which is presumably Monero for the next decade. And if we do go past 777 million, we just grow it. It’s not like we have to reset the privacy pool at that time.

So 100 milliseconds isn’t great. I don’t think it’s quite acceptable yet. But with some academic work, which I’ve already started discussing with other researchers in the space, notably the cryptographers from Firo, which I would currently say is Aram directly representing Firo, and Aaron representing Cypherstack currently working with Firo on their new privacy protocol, Lelantus Spark. With work that I’m discussing with them, we would get it down to 33 milliseconds pretty quickly. And when we get to 33 milliseconds, this actually becomes extremely feasible.

The Grootle proofs being discussed with Seraphis, which would give us a ring size of 128, are 3.7 milliseconds. So yes, I am saying 10 times slower, but further optimizations are still available. The Curve Tree’s paper, the academic paper behind it, they claim they got it down to just 2 milliseconds in total. And I think they counted that in ways which I wouldn’t exactly agree with. But what I’m trying to say is if we’re within an order of magnitude, while it might be 10 times slower I would say it’s definitively worth the simplification of development and not only the simplification of development, but also just full chain membership proofs and never having to worry about rings again. And even once it’s within 10x, I do legitimately believe we can just get it 3 to 5x slower. For a ring size that’s 5 million times bigger.

The other consideration is actually something Justin Berman brought up to me, J Berman. The performance of the node overall will drastically change. Right now a decent part of transaction verification time is pulling up the ring data from the hard drive in order to verify the ring signature. And this isn’t actually something I’d consider, just having to get all of that data off the disk. And with a Curve Tree solution, we don’t have to get that data anymore because we no longer have rings. There are other performance issues with Curved Trees. We have to build a tree. So instead of writing each output to the database, we have to write the tree data to the database. And that tree data is a bit more expensive to calculate. So there are trade-offs, but we’ll see.

As for the security of this, I just wanted to get a couple of the frequently asked questions out of the way. Is this moon math? That’s what most people say when technology popularized by Zcash is discussed. And I would say, no, this is not moon math. Again, it’s using Bulletproofs. Technically my work is using Bulletproofs+, which is already within Monero, already used by Monero, already reviewed and understood by people in Monero. It definitely does require a lot of knowledge. I’m not saying I’m gonna teach everyone here today exactly how Bulletproof works, but Amir does have a talk, Amir Taaki, Neurodnic. They have a talk, Sunday I wanna say? Sunday. That goes over a bit more of the math on this if you’re curious. I don’t consider myself a formal cryptographer and I was able to understand it. I definitely think if the right people put in the effort in the community and we keep talking with the current cryptographers we’re talking with, if we keep appreciating koe, if we continue contact with other communities, we’ll definitely be able to push through it.

How much of this has been formally proven? This is something I wanted to really include thanks to my friend, who is constantly complaining about formal proofs. Formally proven means it’s academically proven to be secure, unless said academic proof also has a flaw. But that’s why we also verify the academic proofs. Bulletproofs, as I’ve said, already passed Monero review. It’s been formally proven, so on and so on. Curve Trees just uses a pair of Bulletproofs, but that doesn’t mean that Curve Trees is formally proven. I can write a pair of Bulletproofs to verify a program, and I can make it the most insecure program out there. So the Curve Trees as a program, as a program that’s verified by Bulletproofs, that does have to be verified.

It does raise the interesting question though. Do we want it to be formally proven in an academic sense, or do we want it to be formally verified in a programming sense? And this distinction is a bit technical. Basically, do we want to say the academic theory is sane, or do we want to say the code itself is sane? And a lot of research has actually gone into this topic thanks to Ethereum smart contracts, which are formally verified to only allow certain things to happen. And with this type of work, it’s no longer so academic. It is just writing code of mathematical properties. And you can say that’s all proofs. Anyways, it’s very interesting. Curve Trees itself is not proven. You could argue if it needs to be proven. I would say some components of it definitely have to be proven. But I definitely think there’s a clear path forward, and I don’t think it’s going to be bogged down in review for several years.

The only other caveat under the question of what hasn’t been formally proven? Technically, we do use Bulletproofs, but we require something called a vector commitment scheme. I won’t go into that. It’s very technical. I have a later bullet point covering it. We don’t have proofs for that component. So we would need proofs of that. I do believe we can get a proof for the current version pretty quickly. I would have to talk to some photographers about that. But ideally, we improve it. The current version is kind of bad. And if we improve it, that would take more time. But I am hoping that when it comes to reviewing the security, making sure this is academically secure, making sure that the code is done correctly, I’d hope we could get this ready for auditing within six to nine months if it was truly prioritized. Knowing Monero development, I’d say closer to a year, year and three months, but I am actually very hopeful for the rate of development on this.

As for ensuring the security, it’s getting more developers involved, it’s making sure we look up formal verification techniques, it’s starting to talk to auditors, and it’s starting to involve cryptographers. I’ve currently been discussing with one of the authors of one of the techniques used in the proof, Liam Eagen, who did Bulletproofs++, which is an even better version of Bulletproofs+, itself a better version of Bulletproofs. I’ve been talking with them about the security of this, and I plan to continue doing that. So that’s its own discussion.

And this kind of jumps into the next steps. It’s funding formalization of my work. It’s built on top of already formalized techniques. And I’m not here to say otherwise. But there’s definitely, when you implement anything, there’s going to be the developer’s own spin on it. Because you can’t just take a piece of paper and write code that directly matches. The vector commitment scheme, again, comes up. We really have to spend time on that.

The other thing we should do is fund formalization in proofs of Seraphis itself. This is being proposed as a piece of Seraphis. So that means it might be secure as Seraphis expects it, but that doesn’t mean Seraphis as a whole is secure. The Seraphis formalization in proofs was, I believe, planned to be done after most of the development. There’s a lot of discussions there and a lot of niches to get into, but right now I’ll just say is, as we discuss funding formalization and proofs of this current work, we should also be revisiting doing that for Seraphis on a more expedient timeline.

Should be getting developers familiar with the code base? I’ve already reached out to a couple of researchers. Egan who did Bulletproofs++ and a technique directly used in my work. I’ve been talking with Amir Taaki, Neuradnik about some of this work. I’ve been talking with cryptographers from Firo as I prior said. And then of course there’s all the great Monero developers I have yet to bring this up with and I am hoping to do so now.

And then finally this was the question of how should Seraphis move forward? We have a few options. We can move Seraphis forward as planned and two years from now take the performance hit and have twice as slow proofs and twice the maintenance work. We can deploy Seraphis with Grootle, the 128 ring sizes, but we do move to a curve cycle ensuring our future. Or at this point, we could start discussing deploying Seraphis with full chain membership proofs.

And then finally, it’s working the code, or, next it’s working the code base into something ready for production. I have built something that’s meant to be transformed into use for production. I’m not claiming it’s ready for use in production.

And then finally, hiring auditors. Making sure that this is reviewed to all ends of the earth. I’m don’t want to deploy or suggest anything that would threaten Monero, and putting forward a broken proof would definitely threaten Monero. So we’re going to have to be sure as hell that we got it right. Questions, comments, concerns?
